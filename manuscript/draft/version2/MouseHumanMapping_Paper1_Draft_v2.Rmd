---
title: "Mouse Human Mapping Paper 1"
author: "Antoine Beauchamp"
date: "`r format(Sys.Date(), format = '%B %d, %Y')`"
output: 
  pdf_document:
      includes:
        in_header: MouseHumanMapping_Paper1_Header.tex
bibliography: MouseHumanMapping_Paper1.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE,
                      cache.lazy = FALSE)
```

```{r libraries}
#Libraries
suppressPackageStartupMessages(library(tidyverse))
library(grid)
library(gridExtra)
library(pheatmap)
library(ggplotify)
library(ggnewscale)
library(RMINC)
library(MRIcrotome)
library(data.tree)
library(RColorBrewer)
```

```{r functions}
#Functions
source("../../../functions/tree_tools.R")
source("../../../functions/mincBuildArray.R")
source("../../../functions/processing_tools.R")
source("../../../functions/buildSimilarityMatrix.R")
```

```{r import}
#Import data
dfExprMouse <- suppressMessages(read_csv("../../../data/MouseExpressionMatrix_voxel_coronal_maskcoronal_log2_grouped_imputed_labelled.csv"))
dfExprHuman <- suppressMessages(read_csv("../../../data/HumanExpressionMatrix_Samples_pipeline_v1_labelled.csv"))

#Load mouse/human labels (Objects: listLabelsMouseReordered, listLabelsHumanReordered)
load("../../../data/TreeLabelsReordered.RData")

#Import MICe data tree
load("../../../AMBA/data/MouseExpressionTree_DSURQE.RData")
treeMouse <- Clone(treeMouseExpr)
rm(treeMouseExpr)

#Remove white matter and ventricles
pruneAnatTree(treeMouse, 
              nodes = c("fiber tracts", "ventricular systems"),
              method = "AtNode")

#Import AHBA data tree
load("../../../AHBA/data/HumanExpressionTree.RData")
treeHuman <- Clone(treeHumanExpr)
rm(treeHumanExpr)

#Fix human colour names (need to start with #)
treeHuman$Do(function(node){
  node$color_hex_triplet <- str_c("#", node$color_hex_triplet)
})

#Remove white matter and ventricles
pruneAnatTree(treeHuman,
              nodes = c("white matter", "sulci & spaces"),
              method = "AtNode")

#Import DSURQE labels and template
dsurqeLabels <- mincGetVolume("../../../AMBA/data/imaging/DSURQE_40micron_labels.mnc")
dsurqeAnat <- mincGetVolume("../../../AMBA/data/imaging/DSURQE_40micron_average.mnc")
dsurqeMask <- mincGetVolume("../../../AMBA/data/imaging/DSURQE_40micron_mask.mnc")
```

```{r normalization}
#Extract labels from data frames
dfLabelsMouse <- dfExprMouse %>% select(contains("Region"))
dfLabelsHuman <- dfExprHuman %>% select(contains("Region"))

#Normalize mouse data
dfExprMouse_scaled <- dfExprMouse %>% 
  select(-contains("Region")) %>% 
  as.matrix() %>% 
  scaler(axis = "rows") %>% 
  scaler(scale = FALSE, axis = "columns") %>% 
  as_tibble() %>% 
  bind_cols(dfLabelsMouse)

#Normalize human data
dfExprHuman_scaled <- dfExprHuman %>% 
  select(-contains("Region")) %>% 
  as.matrix() %>% 
  scaler(axis = "rows") %>% 
  scaler(scale = FALSE, axis = "columns") %>% 
  as_tibble() %>% 
  bind_cols(dfLabelsHuman)

#Extract genes list from mouse data (same as human)
genes <- colnames(dfExprMouse_scaled)[!str_detect(colnames(dfExprMouse_scaled), "Region")]

rm(dfExprMouse, dfExprHuman)
```

```{r}
treeMouse_11 <- Clone(treeMouse)
pruneAnatTree(treeMouse_11,
              nodes = listLabelsMouseReordered$Region11_reordered,
              method = "BelowNode")
atlasMouse_11 <- hanatToAtlas(treeMouse_11, mincArray(dsurqeLabels))
dfAtlasMouse_11 <- hanatToAtlasDefs(treeMouse_11)

dsurqeAnat_3d <- mincArray(dsurqeAnat)
dsurqeMask_3d <- mincArray(dsurqeMask)

dsurqeAnat_3d[dsurqeMask_3d == 0] <- NA

anatLow <-  700
anatHigh <- 1400
dsurqeAnat_3d[dsurqeAnat_3d >= anatHigh] <- anatHigh
dsurqeAnat_3d[dsurqeAnat_3d <= anatLow] <- anatLow
dims <- dim(dsurqeAnat_3d)

slice <- 100
sliceSelectionAnat <- dsurqeAnat_3d[1:dims[1], 1:dims[2], slice]
colnames(sliceSelectionAnat) <- 1:ncol(sliceSelectionAnat)
rownames(sliceSelectionAnat) <- nrow(sliceSelectionAnat):1

dfSliceSelectionAnat <- sliceSelectionAnat %>% 
  as_tibble(rownames = "x") %>% 
  pivot_longer(-x, names_to = "y", values_to = "Intensity") %>% 
  mutate_all(.funs = as.numeric)

atlasMouse_11_3d <- mincArray(atlasMouse_11)
atlasMouse_11_3d[dsurqeMask_3d == 0] <- NA
atlasMouse_11_3d[atlasMouse_11_3d == 0] <- NA
sliceSelectionLabels <- atlasMouse_11_3d[1:dims[1], 1:dims[2], slice]
colnames(sliceSelectionLabels) <- 1:ncol(sliceSelectionLabels)
rownames(sliceSelectionLabels) <- nrow(sliceSelectionLabels):1

dfSliceSelectionLabels <- sliceSelectionLabels %>% 
  as_tibble(rownames = "x") %>% 
  pivot_longer(-x, names_to = "y", values_to = "Label") %>% 
  mutate_all(.funs = as.numeric) 

dfSliceSelection <- inner_join(dfSliceSelectionAnat,
                               dfSliceSelectionLabels,
                               by = c("x", "y"))

dfMouseColours <- treeMouse_11$Get("color_hex_triplet", filterFun = isLeaf) %>%
  enframe(name = "Structure",
          value = "Colour") %>% 
  inner_join(dfAtlasMouse_11,
             by = "Structure") %>% 
  semi_join(dfSliceSelection,
            by = "Label") %>% 
  arrange(Label)

dfSliceSelection <- dfSliceSelection %>% 
  filter(y <= 400) %>% 
  mutate(Label = factor(Label))

asp <- max(dfSliceSelection$x)/max(dfSliceSelection$y)

sliceAMBALegend <- ggplot(dfSliceSelection, aes(x = x, y = y)) + 
  geom_tile(aes(fill = Intensity),
            alpha = 0.5) + 
  scale_fill_gradient(low = gray.colors(255)[1],
                      high = gray.colors(255)[255],
                      na.value = 'transparent',
                      guide = "none") + 
  new_scale_fill() + 
  geom_tile(aes(fill = Label)) + 
  scale_fill_manual(na.value = 'transparent',
                      values = dfMouseColours$Colour,
                    guide = "none") +
  coord_fixed() +
  theme_void() +
  # theme_minimal() +
  theme(plot.margin = margin(t = 0, r = 0, b = 0, l = 0))
sliceAMBALegend_grob <- ggplotGrob(sliceAMBALegend) %>% grid.force()
sliceAMBALegend_panel_grob <- getGrob(sliceAMBALegend_grob, "panel.7-5-7-5")

rm(treeMouse_11,
   atlasMouse_11,
   dfAtlasMouse_11,
   dsurqeAnat_3d,
   dsurqeMask_3d,
   slice,
   sliceSelectionAnat,
   atlasMouse_11_3d,
   sliceSelectionLabels,
   dfSliceSelectionAnat,
   dfSliceSelectionLabels,
   dfSliceSelection,
   dfMouseColours)
```

# Abstract

# Introduction {#intro}

\onehalfspacing

Animal models play an indispensable role in neuroscience research, both in the context of preclinical translation and in that of basic science. While numerous species have been used to model the human brain, the mouse has emerged as the most prominent of these, due to its rapid life cycle, straightforward husbandry, and amenability to genetic engineering \edit{References}. Mouse models have proven to be extremely useful for understanding the diverse features of the brain, from its molecular neurobiological properties to its large-scale network properties \edit{References}. While studying the mouse brain is a worthwhile endeavour in its own right, the primary purpose of using the mouse as a model system is to understand something about the human brain. Consequently it is crucial that neuroscientific findings discovered using mouse models be translatable to humans. In order to accomplish this translation, a correspondence must be established between the brains of the two species. Historically this has been done by designating certain pairs of neuroanatomical regions as homologous. Such homologues are defined on the basis of a variety of biological and physical properties, including cytoarchitecture, myeloarchitecture, connectivity, and morphology \edit{References} \edit{Include mention of evolution and embryonic development}. This approach has worked well to identify general correspondences between mouse and human brains, but it is not without limitations. In particular, defining neuroanatomical homologues in this way is an entirely qualitative exercise, in which atlas labels from one species are matched to labels in the other species. Additionally, such semantic matches are usually taken to be one-to-one, eliminating the possibility that a given area in one brain may map onto multiple areas in the other. Finally, many brain regions don't have an obvious homologue in the other species. In such instances, there is no way to assess the degree of dissimilarity between species. These limitations highlight the need to develop new ways of comparing brains across species \edit{Can probably make these sentences on limitations better}.


Over the last decade, researchers in the field of comparative neuroscience have begun to explore ways to make more formal comparisons between the brains of different species. This has been made possible by advances in data acquisition technologies, particularly magnetic resonance imaging (MRI), as well as advances in computing power and data analytic methodology. Thus far, this line of research has primarily explored homologies between the brains of humans and non-human primates. In 2013, Mars et al. first used Passingham's notion of a connectivity fingerprint [@Passingham2002] to identify the macaque homologue of the human temporoparietal junction [@Mars2013]. The connectivity fingerprint is a signature that characterizes how a given region of interest is connected to a set of pre-specified target regions. These targets are chosen to be homologous between the species of interest, where the definition of homology is based on prior information. Since each region can be uniquely identified by its connectivity fingerprint, it is possible to match fingerprints across species to identify regional homologues. Mars et al. generated their connectivity fingerprints using resting-state functional MRI (rs-fMRI) data. By building these fingerprints for voxels in the human temporoparietal junction and matching them to the fingerprints of voxels in the macaque brain, they were able to determine which macaque region was most likely to be homologous. Since then it has been shown that connectivity fingerprints can be used to perform a number of different cross-species comparisons, including matching the fingerprints for a set of pre-specific regions of interest in one species to a template of the brain in the other species, and matching a connectivity fingerprint across a specific region of the brain (e.g. the cortex) in order to identify the closest cross-species match [@Mars2016]. In 2018, Mars et al. extended the idea of a connectivity fingerprint to a whole-brain connectivity blueprint, in which a connectivity fingerprint is generated for every region in the brain [@Mars2018]. In this case, rather than building the connectivity fingerprints using functional connectivity to pre-specified target regions assumed to be homologous, they used a given region’s connection to white matter tracts common among all higher primates. While this line of research has been focused primarily on cross-species comparisons between humans and non-human primates, the development of novel methods has encouraged neuroscientists to think in new ways about exploring cross-species homologies. More recently, Balsters et al. applied the concept of connectivity fingerprints to assess the degree of homology in the striatum of mice, non-human primates and humans, finding that the nucleus accumbens was well conserved across species, but that the human striatum contained a large number of voxels with no obvious homologues in the mouse [@Balsters2020].

Together these results highlight a framework for making formal comparisons between the brains of different species [@Mars2018_2]. Rather than relying on the definition of homologous neuroanatomical pairs, the degree of similarity between voxels or regions in the brain is assessed directly using an intermediate common space. In order to serve as a bridge between the different species, the common space is constructed using quantitative maps of some underlying homologous biological feature. For instance, in the case of rs-fMRI data [@Mars2013], the space is built using a seed region’s functional connections to a set of target regions, which are assumed a priori to be homologous between the species. With white matter tractography data [@Mars2018], the space is built using a region’s connections to homologous white matter tracts. While cross-species comparisons can be accomplished using connectivity profiles, connectivity maps are by no means the only kind of data that can be used to define a common space. In particular, the availability of whole-brain spatial gene expression data sets provides an opportunity to build such a space using the expression patterns of homologous genes [@Lein2007; @Hawrylycz2012]. Using such data sets, it has been shown that certain broadly defined regions in the mouse and human brains exhibit similarity on the basis of their gene expression profiles [@Myers2017].

Here we examine the similarities between mouse and human brains using a common space constructed from the regional expression of homologous genes. \edit{Say something about many to many mappings}

\edit{Close off Introduction}


# Results

## Homologous genes capture broad similarities in the mouse and human brains {#results-1}

```{r results1-text1}
#For code chunk navigation purposes
```

We first examined the pattern of homologies that emerged when comparing mouse and human brain regions on the basis of their gene expression profiles. We constructed a gene expression common space using widely available data sets from the Allen Institute for Brain Science: the Allen Mouse Brain Atlas (AMBA) [@Lein2007] and the Allen Human Brain Atlas (AHBA) [@Hawrylycz2012]. These data sets provide whole-brain coverage of expression intensity for thousands of genes in the mouse and human genomes. For our purposes we filtered these gene sets to retain only mouse-human homologous genes. This subset was obtained using the NCBI HomoloGene system \edit{Reference}. Prior to analysis, we ran both data sets through a preprocessing pipeline that included quality control checks, normalization procedures, and aggregation of the expression values under a set of atlas labels (see [Materials and methods](#materials-methods)). The result was a gene expression blueprint in either species, describing the normalized expression of `r length(genes)` homologous genes across 67 mouse regions and 88 human regions \edit{How were these obtained?}. We quantified the degree of similarity between all pairs of mouse and human regions in these blueprints using the Pearson correlation coefficient, resulting in a mouse-human similarity matrix (Figure 1, panel A).

As described previously by Myers [@Myers2017], we find that the similarity matrix exhibits broad patterns of positive correlation values between the mouse and human brains. These clusters of similarity correspond to coarse neuroanatomical regions that are generally well-defined in both species. For instance, we observe that the mouse isocortex is broadly similar to the human cerebral cortex, with the exception of the hippocampal formation, which forms a unique cluster. Similarly the mouse and human cerebellar hemispheres cluster together, while the cerebellar nuclei are set apart. These broad clusters of similarity are evident in the correlation matrix, but the ability to resolve regional matches on a finer scale is limited when using all homologous genes in this way. This is especially true for regions within the cortex and the cerebellum, which exhibit a high degree of internal homogeneity. For instance, the similarity profiles of the human precentral gyrus and cuneus both exhibit a plateau of similarity to the mouse isocortex. Within this plateau, the profiles of the two seeds are similar. The same is true of cerebellar cortical regions, such as the human crus 1, which is broadly similar to all regions in the mouse cerebellar cortex (Figure 1, panels B and C). Thus the regional expression patterns of mouse-human homologous genes can be used to identify general similarities between the brains of the two species, but the ability to identify finer scale matches is limited.

```{r results1-fig1-panelA-heatmap}
# Figure 1: Heatmap processing ------------------------------------------------

#Compute average gene expression for 67 mouse brain regions
matExprMouse_scaled <- dfExprMouse_scaled %>% 
  select(Region = Region67,
         genes) %>% 
  group_by(Region) %>% 
  summarise_all(mean) %>% 
  ungroup() %>% 
  column_to_rownames("Region") %>% 
  as.matrix() %>% 
  t()

#Compute average gene expression for 88 human brain regions
matExprHuman_scaled <- dfExprHuman_scaled %>% 
  select(Region = Region88,
         genes) %>% 
  group_by(Region) %>% 
  summarise_all(mean) %>% 
  ungroup() %>% 
  column_to_rownames("Region") %>% 
  as.matrix() %>% 
  t()

#Compute human-mouse similarity matrix in gene space
matSim_H88M67_AllGenes <- buildSimilarityMatrix(x1 = matExprHuman_scaled, 
                                                x2 = matExprMouse_scaled)

#Order similarity matrix rows/columns according to brain organization
matSim_H88M67_AllGenes <- matSim_H88M67_AllGenes[,match(listLabelsMouseReordered$Region67_reordered, colnames(matSim_H88M67_AllGenes))]
matSim_H88M67_AllGenes <- matSim_H88M67_AllGenes[match(listLabelsHumanReordered$Region88_reordered, rownames(matSim_H88M67_AllGenes)),]

#Create annotation data frame for mouse regions
#Annotations use 11 coarser brain ROIs
dfAnnotationMouse <- dfLabelsMouse %>% 
  select(Region67, Region11) %>% 
  distinct() %>% 
  column_to_rownames("Region67") %>% 
  rename(MouseRegion = Region11)

#Order mouse annotations according to brain organization
indOrderMouse <- match(listLabelsMouseReordered$Region67_reordered, rownames(dfAnnotationMouse))
dfAnnotationMouse$MouseRegion <- dfAnnotationMouse$MouseRegion[indOrderMouse]
rownames(dfAnnotationMouse) <- rownames(dfAnnotationMouse)[indOrderMouse]

dfAnnotationMouse$MouseRegion <- factor(dfAnnotationMouse$MouseRegion, levels = listLabelsMouseReordered$Region11_reordered)

#Repeat for human regions
dfAnnotationHuman <- dfLabelsHuman %>% 
  select(Region88, Region16) %>% 
  distinct() %>% 
  column_to_rownames("Region88") %>% 
  rename(HumanRegion = Region16)

indOrderHuman <- match(listLabelsHumanReordered$Region88_reordered, rownames(dfAnnotationHuman))
dfAnnotationHuman$HumanRegion <- dfAnnotationHuman$HumanRegion[indOrderHuman]
rownames(dfAnnotationHuman) <- rownames(dfAnnotationHuman)[indOrderHuman]

dfAnnotationHuman$HumanRegion <- factor(dfAnnotationHuman$HumanRegion, levels = listLabelsHumanReordered$Region16_reordered)

#Prune mouse tree to 11 regions for cluster annotations
treeMouse_11 <- Clone(treeMouse)
pruneAnatTree(treeMouse_11,
              nodes = listLabelsMouseReordered$Region11,
              method = "BelowNode")

#Prune human tree to 16 regions for cluster annotations
treeHuman_16 <- Clone(treeHuman) 
pruneAnatTree(treeHuman_16,
              nodes = listLabelsHumanReordered$Region16,
              method = "BelowNode")

#Get colour annotation from trees
coloursMouse <-  treeMouse_11$Get("color_hex_triplet", filterFun = isLeaf)
indOrderMouseColours <- match(listLabelsMouseReordered$Region11_reordered, names(coloursMouse))
coloursMouse <- coloursMouse[indOrderMouseColours]

coloursHuman <- treeHuman_16$Get("color_hex_triplet", filterFun = isLeaf)
indOrderHumanColours <- match(listLabelsHumanReordered$Region16_reordered, names(coloursHuman))
coloursHuman <- coloursHuman[indOrderHumanColours]

annotation_colours <- list(MouseRegion = coloursMouse,
                           HumanRegion = coloursHuman)

#Create a set of modified colours for clearer visualization. 
#To be used for text colouring mostly
annotation_colours_mod <- annotation_colours
annotation_colours_mod$MouseRegion["Isocortex"] <- "#68EC68"
annotation_colours_mod$MouseRegion["Cerebellar cortex"] <- "#E6E67B"
annotation_colours_mod$MouseRegion["Cerebellar nuclei"] <- "#E6E67B"

annotation_colours_mod$HumanRegion["insula"] <- "#E6E658"
annotation_colours_mod$HumanRegion["diencephalon"] <- "#85DD63"
annotation_colours_mod$HumanRegion["pons"] <- "#00E0A4"


# Figure 1: Heatmap base ggplot -----------------------------------------------

#Generate similarity matrix heatmap and convert to ggplot object
fig1_heatmap_ggplot <- pheatmap(matSim_H88M67_AllGenes,
                                cluster_cols = F, cluster_rows = F,
                                border_color = NA,
                                show_rownames = F, show_colnames = F,
                                annotation_row = dfAnnotationHuman,
                                annotation_col = dfAnnotationMouse,
                                annotation_colors = annotation_colours,
                                legend = T,
                                annotation_legend = F,
                                annotation_names_col = F, annotation_names_row = F) %>% 
  as.ggplot()



# Figure 1: Heatmap matrix ----------------------------------------------------

#Convert the pheatmap plot to grob and force the gTree
fig1_heatmap_main_grob <- ggplotGrob(fig1_heatmap_ggplot) %>% grid.force()

#Extract the matrix grob from the plot
fig1_heatmap_main_matrix_grob <- fig1_heatmap_main_grob %>% 
  getGrob("matrix.4-3-4-3") 

#Extract the row annotations and reposition them
fig1_heatmap_main_rowannotations_grob <- fig1_heatmap_main_grob %>% 
  getGrob("row_annotation.4-2-4-2") %>%
  editGrob(x = unit(0,'npc'),
           width = unit(0.9, 'npc'),
           just = "left")

#Exract the column annotations and reposition them
fig1_heatmap_main_colannotations_grob <- fig1_heatmap_main_grob %>% 
  getGrob("col_annotation.3-3-3-3") %>% 
  editGrob(y = unit(0.1, 'npc'),
           height = unit(0.9, 'npc'),
           just = "bottom")

#Extract the legend 
fig1_heatmap_main_legend_grob <- fig1_heatmap_main_grob %>% 
  getGrob("legend.4-5-5-5")

#Recombine the plot into a single grob layout
#Annotation sizes are fixed in inches. Matrix fills the remaining space
fig1_heatmap_main_grob <- arrangeGrob(fig1_heatmap_main_colannotations_grob,
                                      fig1_heatmap_main_rowannotations_grob,
                                      fig1_heatmap_main_matrix_grob,
                                      layout_matrix = rbind(c(NA, 1),
                                                            c( 2, 3)),
                                      widths = unit(c(0.1, 0.9), c('inch', 'null')),
                                      heights = unit(c(0.1, 0.9), c('inch', 'null')))



# Figure 1: Heatmap legend ----------------------------------------------------

fig1_heatmap_legend_title <- textGrob("Correlation",
                                      x = unit(0.5, 'inch'),
                                      y = 0.8,
                                      rot = 90)
fig1_heatmap_legend_grob <- gTree(children = gList(fig1_heatmap_main_legend_grob,
                                                   fig1_heatmap_legend_title))



# Figure 1: Heatmap mouse labels ----------------------------------------------

#1. Mouse label text
#The mouse labels are acronyms for 11 coarse regions
fig1_heatmap_labsmouse_text <- treeMouse_11$Get("acronym", filterFun = isLeaf) %>% 
  enframe(name = "Region",
          value = "Acronym") %>% 
  mutate(Region = factor(Region, levels = listLabelsMouseReordered$Region11_reordered)) %>% 
  arrange(Region) %>% 
  pull(Acronym) %>% 
  as.character()

#Mouse label x positions
fig1_heatmap_labsmouse_text_x <- c(0.305, #Cortical subplate
                                   0.533, #Olfactory areas
                                   0.952, #Hippocampal formation
                                   1.637, #Isocortex
                                   2.284, #Cerebral nuclei
                                   2.474, #Interbrain
                                   2.665, #Midbrain
                                   2.855, #Pons
                                   3.045, #Medulla
                                   3.312, #Cerebellar cortex
                                   3.655) #Cerebellar nuclei

#Mouse label y positions are organized in two rows
fig1_heatmap_labsmouse_text_y <- rep(c(0.3,0.125), length.out = length(fig1_heatmap_labsmouse_text))

#Colours for the mouse labels
fig1_heatmap_labsmouse_text_col <- annotation_colours_mod$MouseRegion

#Create the text grob for the mouse labels
fig1_heatmap_labsmouse_text_grob <- textGrob(fig1_heatmap_labsmouse_text,
                                             x = unit(fig1_heatmap_labsmouse_text_x, 'inch'),
                                             y = unit(fig1_heatmap_labsmouse_text_y, 'inch'),
                                             just = "centre",
                                             gp = gpar(fontsize = 10, 
                                                       col = fig1_heatmap_labsmouse_text_col,
                                                       fontface = "bold"))

#2. Mouse label lines
#Positions of the lines are dependent on text positions
fig1_heatmap_labsmouse_line_x0 <- fig1_heatmap_labsmouse_text_x + c(-0.1, #Cortical subplate
                                                                    NA, #Olfactory areas
                                                                    0, #Hippocampal formation
                                                                    NA, #Isocortex
                                                                    0, #Cerebral nuclei
                                                                    NA, #Interbrain
                                                                    0, #Midbrain
                                                                    NA, #Pons
                                                                    -0.148, #Medulla
                                                                    NA, #Cerebellar cortex
                                                                    0.13) #Cerebellar nuclei
fig1_heatmap_labsmouse_line_x1 <- fig1_heatmap_labsmouse_line_x0 + c(0, #Cortical subplate
                                                                     0, #Olfactory areas
                                                                     0, #Hippocampal formation
                                                                     0, #Isocortex
                                                                     0, #Cerebral nuclei
                                                                     0, #Interbrain
                                                                     0, #Midbrain
                                                                     0, #Pons
                                                                     0.148, #Medulla
                                                                     0, #Cerebellar cortex
                                                                     0) #Cerebellar nuclei
fig1_heatmap_labsmouse_line_y0 <- rep(0, length.out = length(fig1_heatmap_labsmouse_text))
fig1_heatmap_labsmouse_line_y1 <- fig1_heatmap_labsmouse_text_y - 0.08

#Create the mouse label line grob
fig1_heatmap_labsmouse_line_grob <- segmentsGrob(x0 = unit(fig1_heatmap_labsmouse_line_x0, 'inch'),
                                                 x1 = unit(fig1_heatmap_labsmouse_line_x1, 'inch'),
                                                 y0 = unit(fig1_heatmap_labsmouse_line_y0, 'inch'),
                                                 y1 = unit(fig1_heatmap_labsmouse_line_y1, 'inch'),
                                                 gp = gpar(col = annotation_colours$MouseRegion,
                                                           lwd = 1))

#3. Mouse label title
fig1_heatmap_labsmouse_title_grob <- textGrob("Mouse regions",
                                              x = 0.5, 
                                              y = unit(0.5, 'inch'))

#Combine the mouse label grobs into one
fig1_heatmap_labsmouse_grob <- gTree(children = gList(fig1_heatmap_labsmouse_text_grob,
                                                      fig1_heatmap_labsmouse_line_grob,
                                                      fig1_heatmap_labsmouse_title_grob))



# Figure 1: Heatmap human labels ----------------------------------------------

#1. Human label text
fig1_heatmap_labshuman_text <- treeHuman_16$Get("acronym", filterFun = isLeaf) %>% 
  enframe(name = "Region",
          value = "Acronym") %>% 
  mutate(Region = factor(Region, levels = listLabelsHumanReordered$Region16_reordered)) %>% 
  arrange(Region) %>% 
  pull(Acronym) %>% 
  as.character()

fig1_heatmap_labshuman_text_x <- rep(0.9, length.out = length(fig1_heatmap_labshuman_text))
fig1_heatmap_labshuman_text_y <- c(0.97, #Claustrum
                                   0.92, #Limbic lobe
                                   0.79, #Frontal lobe
                                   0.685, #Insula
                                   0.645, #Occipital lobe
                                   0.59, #Parietal lobe
                                   0.50, #Temporal lobe
                                   0.455, #Amygdala
                                   0.42, #Basal ganglia
                                   0.39, #Basal forebrain
                                   0.355, #Diencephalon
                                   0.31, #Mesencephalon
                                   0.282, #Pons,
                                   0.25, #Myelencephalon,
                                   0.15, #Cerebellar cortex,
                                   0.01) #Cerebellar nuclei
fig1_heatmap_labshuman_text_y <- c(4.850, #Claustrum
                                   4.60, #Limbic lobe
                                   3.950, #Frontal lobe
                                   3.425, #Insula
                                   3.225, #Occipital lobe
                                   2.950, #Parietal lobe
                                   2.5, #Temporal lobe
                                   2.275, #Amygdala
                                   2.10, #Basal ganglia
                                   1.950, #Basal forebrain
                                   1.775, #Diencephalon
                                   1.550, #Mesencephalon
                                   1.410, #Pons,
                                   1.250, #Myelencephalon,
                                   0.750, #Cerebellar cortex,
                                   0.050) #Cerebellar nuclei
fig1_heatmap_labshuman_text_col <- annotation_colours_mod$HumanRegion
fig1_heatmap_labshuman_text_grob <- textGrob(fig1_heatmap_labshuman_text,
                                             x = unit(fig1_heatmap_labshuman_text_x, 'inch'),
                                             y = unit(fig1_heatmap_labshuman_text_y, 'inch'),
                                             just = c("right", "centre"),
                                             gp = gpar(fontsize = 10,
                                                       fontface = "bold",
                                                       col = fig1_heatmap_labshuman_text_col))


#2. Human label lines
# Only need a line for the myelencephalon
fig1_heatmap_labshuman_line_grob <- segmentsGrob(x0 = 0.9, x1 = 1,
                                                 y0 = 0.25, y1 = 0.27,
                                                 gp = gpar(col = annotation_colours$HumanRegion[[14]],
                                                           lwd = 1))

#3. Human label title
fig1_heatmap_labshuman_title_grob <- textGrob("Human regions",
                                              x = 0.4, y = 0.5,
                                              rot = 90)

#Combine the human label grobs into one
fig1_heatmap_labshuman_grob <- gTree(children = gList(fig1_heatmap_labshuman_text_grob,
                                                      fig1_heatmap_labshuman_line_grob,
                                                      fig1_heatmap_labshuman_title_grob))
```

```{r results1-fig1-panelB-sliceseries}
#Set human seed regions
seeds <- c("precentral gyrus",
           "cuneus",
           "crus I")

#Generate a mouse tree with 67 leaf nodes
treeMouse_67 <- Clone(treeMouse)
pruneAnatTree(treeMouse_67,
              nodes = listLabelsMouseReordered$Region67_reordered,
              method = "BelowNode")

#Create a mouse atlas with 67 regions
atlasMouse_67 <- hanatToAtlas(treeMouse_67, mincArray(dsurqeLabels))
dfAtlasMouse_67 <- hanatToAtlasDefs(treeMouse_67)

#Extract seed similarities
dfSeedSim_AllGenes <- matSim_H88M67_AllGenes %>% 
  t() %>% 
  as_tibble(rownames = "Target") %>% 
  select(Target, seeds)

#Convert seed similarities to MINC array
listSeedSim_AllGenes <- map(.x = select(dfSeedSim_AllGenes, -Target),
                            .f = mincBuildArray,
                            labels = atlasMouse_67,
                            defs = dfAtlasMouse_67,
                            values.names = dfSeedSim_AllGenes$Target)

#Apply mask to the background anatomy
dsurqeAnat[dsurqeMask == 0] <- 0

#Create the base slice series
fig1_sliceseries_base <- sliceSeries(nrow = 8, ncol = 1, begin = 70, end = 330) %>% 
  anatomy(mincArray(dsurqeAnat), low = 700, high = 1400) %>%
  overlay(mincArray(listSeedSim_AllGenes[[seeds[1]]]), low = 0.1, high = 0.4, symmetric = TRUE) %>% 
  sliceSeries() %>% anatomy() %>% 
  overlay(mincArray(listSeedSim_AllGenes[[seeds[2]]]), low = 0.1, high = 0.4, symmetric = TRUE) %>%
  sliceSeries() %>% anatomy() %>% 
  overlay(mincArray(listSeedSim_AllGenes[[seeds[3]]]), low = 0.1, high = 0.4, symmetric = TRUE)

#Convert the slice series to grob
fig1_sliceseries_grob <- grobify(fig1_sliceseries_base)

#Generate and extract the legend from the slice series
fig1_sliceseries_legend_grob <- fig1_sliceseries_base %>% 
  legend("Correlation") %>% 
  grobify() %>% 
  getGrob("legend")

#Create text grob for slice series titles
seedColours <- character(length(seeds))
for(i in 1:length(seeds)){
  seedColours[i] <- FindNode(treeHuman, seeds[i])[["color_hex_triplet"]]
}
fig1_sliceseries_labels <- str_to_title(seeds) %>% str_replace("Gyrus", "gyr.")
fig1_sliceseries_labels_grob <- textGrob(fig1_sliceseries_labels,
                                         x = c(0.18, 0.5, 0.845),
                                         y = unit(0.125, 'inch'),
                                         just = "bottom",
                                         gp = gpar(fontsize = 10,
                                                   col = seedColours))
fig1_sliceseries_title_grob <- textGrob("Human seed regions",
                                        x = 0.5, y = unit(0.5, 'inch'))
fig1_sliceseries_text_grob <- gTree(children = gList(fig1_sliceseries_labels_grob,
                                                     fig1_sliceseries_title_grob))
```

```{r results1-fig1-panelC-linechart}
#Convert seed similarity data frame to long form
dfSeedSim_AllGenes_plot <- dfSeedSim_AllGenes %>% 
  gather(key = "Seed", value = "Correlation", -Target) %>% 
  mutate(Seed = factor(Seed, levels = listLabelsHumanReordered$Region88_reordered),
         Target = factor(Target, levels = listLabelsMouseReordered$Region67_reordered)) 

dfSeedSim_Annotations <- dfSeedSim_AllGenes_plot %>% 
  filter(Target %in% c("Primary motor area", "Visual areas", "Crus 1")) %>% 
  mutate(Match = case_when(Target == "Primary motor area" ~ "precentral gyrus",
                           Target == "Visual areas" ~ "cuneus",
                           Target == "Crus 1" ~ "crus I")) %>% 
  filter(Seed == Match)

dfSeedSim_TextColours <- annotation_colours_mod$MouseRegion %>%
  enframe(name = "Region11",
          value = "Colour") %>% 
  inner_join(dfLabelsMouse %>% 
               select(Region11, Region67) %>% 
               distinct(),
             by = "Region11") %>% 
  mutate(Region67 = factor(Region67, levels = listLabelsMouseReordered$Region67_reordered))

#Plot parameters
ylims <- c(-0.3, 0.5)
ybreaks <- seq(-0.2, 0.4, by = 0.2)

#Create base line chart
fig1_linechart <- ggplot(dfSeedSim_AllGenes_plot,
                         aes(x = Target, y = Correlation, col = Seed, group = Seed)) + 
  geom_line() + 
  geom_segment(data = dfSeedSim_Annotations,
               aes(x = Target,
                   xend = Target,
                   y = -Inf,
                   yend = Correlation,
                   col = Seed),
               linetype = "dashed",
               size = 0.8) +
  geom_point(data = dfSeedSim_Annotations) + 
  coord_cartesian(ylim = ylims) + 
  scale_y_continuous(breaks = ybreaks) +
  scale_color_manual(labels = str_replace(str_to_title(seeds), "Gyrus", "gyrus"),
                     values = seedColours) + 
  labs(x = "Mouse region",
       col = "Human seed regions") + 
  theme_bw() +  
  theme(axis.text.x = element_text(angle = 45,
                                   hjust = 1,
                                   size = 6,
                                   colour = dfSeedSim_TextColours$Colour,
                                   face = "bold"),
        plot.margin = margin(t = 0, l = 0, r = 0, b = 0, unit = 'inch'))
fig1_linechart_grob <- ggplotGrob(fig1_linechart) %>% grid.force()

#Extract legend grob from ggplot
fig1_linechart_panel_grob <- getGrob(fig1_linechart_grob, "panel.7-5-7-5")
fig1_linechart_ytext_grob <- getGrob(fig1_linechart_grob, "axis-l.7-4-7-4")
fig1_linechart_ytitle_grob <- getGrob(fig1_linechart_grob, "ylab-l.7-3-7-3")
fig1_linechart_xtext_grob <- getGrob(fig1_linechart_grob, "axis-b.8-5-8-5")
fig1_linechart_xtitle_grob <- getGrob(fig1_linechart_grob, "xlab-b.9-5-9-5")
fig1_linechart_legend_grob <- getGrob(fig1_linechart_grob, "guides.3-3-3-3")
```

```{r results1-fig1-grob}
#Heatmap aspect ratio, figure height and width
matAsp = ncol(matSim_H88M67_AllGenes)/nrow(matSim_H88M67_AllGenes)
matHeight <- 5
matWidth <- matAsp*matHeight

#Slice series width
ssWidth <- matWidth*0.722

#Grob for figure 1
fig1_grob <- arrangeGrob(fig1_heatmap_main_grob, #1
                         fig1_heatmap_legend_grob, #2
                         fig1_heatmap_labsmouse_grob, #3
                         fig1_heatmap_labshuman_grob, #4,
                         fig1_sliceseries_grob, #5
                         fig1_sliceseries_text_grob, #6
                         fig1_sliceseries_legend_grob, #7
                         fig1_linechart_panel_grob,#8
                         fig1_linechart_ytext_grob,#9
                         fig1_linechart_ytitle_grob,#10
                         fig1_linechart_xtext_grob, #11
                         fig1_linechart_xtitle_grob,#12
                         fig1_linechart_legend_grob,#13
                         layout_matrix = rbind(c(NA, NA, NA,  3, NA, NA,  6, NA),
                                               c( 4,  4,  4,  1, NA,  2,  5,  7),
                                               c(NA, NA, NA, NA, NA, NA, NA, NA),
                                               c(NA, 10,  9,  8,  8,  8,  8, 13),
                                               c(NA, NA, NA, 11, 11, 11, 11, NA),
                                               c(NA, NA, NA, 12, 12, 12, 12, NA)),
                         widths = unit(c(0.4, 0.3, 0.3, matWidth, 0.08, 0.78, ssWidth, 1.73), 'inch'),
                         heights = unit(c(0.7, matHeight, 0.3, 1.1, 1.1, 0.2), 'inch'))
```

```{r results1-fig1-interactive, include=FALSE, echo = FALSE, fig.width=10, fig.height = 8.6}
grid.newpage()
grid.draw(fig1_grob)
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.25, 5.25, 0.25), 'inch'), 
          y = unit(c(8.299, 8.299, 2.55), 'inch'),
          gp = gpar(fontsize = 14, fontface = "bold"))
sliceAMBAWidth <- 1.1
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(9.15, 'inch'),
              y = unit(0.8, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
```

```{r results1-fig1-caption}
fig1_cap_A <- str_c("(A) Similarity matrix displaying the correlation between 67 mouse regions and 88 human regions based on the expression of", length(genes), "homologous genes. Column annotations feature 11 coarsely defined mouse regions: Cortical subplate (CTXsp), olfactory areas (OLF), hippocampal formation (HPF), isocortex, cerebral nuclei (CNU), interbrain (IB), midbrain (MB), pons (P), medulla (MY), cerebellar cortex (CBX), cerebellar nuclei (CBN). Row annotations feature 16 coarsely defined human regions: Claustrum (Cl), limbic lobe (LL), frontal lobe (FL), insula (Ins), occipital lobe (OL), parietal lobe (PL), temporal lobe (TL), amygdala (Amg), basal ganglia (BG), basal forebrain (BF), diencephalon (DIE), mesencephalon (MES), pons, myelencephalon (MY), cerebellar cortex (CbCx), cerebellar nuclei (CbN). Broad patterns of similarity are evident between coarsely defined brain regions, while correlation patterns are mostly homogeneous within these regions.", sep = " ")
fig1_cap_B <- "(B) Mouse brain slices showing similarity profiles for the human precentral gyrus, cuneus and crus I. Correlation patterns for the precentral gyrus and cuneus are highly similar to one another and broadly similar to most isocortical regions. The similarity profile for the crus I exhibits homogeneous similarity to the mouse cerebellum."
fig1_cap_C <- "(C) Anatomically-ordered line charts displaying the similarity profiles for the seed regions in (B). Dashed lines indicate the canonical mouse homologue for each human seed."
fig1_cap <- str_c("Mouse-human similarity in gene expression space.",
                  fig1_cap_A,
                  fig1_cap_B,
                  fig1_cap_C,
                  "Annotation colours correspond to atlas colours from the AMBA and AHBA for mouse and human regions respectively.",
                  sep = " ")
```

```{r results1-fig1-options}
fig1_width <- 10
fig1_height <- 8.6
knitr::opts_chunk$set(include = TRUE,
                      echo = FALSE,
                      fig.width = fig1_width,
                      fig.height = fig1_height,
                      fig.cap = fig1_cap)
```

```{r results1-fig1-print}
grid.newpage()
grid.draw(fig1_grob)
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.25, 5.25, 0.25), 'inch'), 
          y = unit(c(8.299, 8.299, 2.55), 'inch'),
          gp = gpar(fontsize = 14, fontface = "bold"))
sliceAMBAWidth <- 1.1
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(9.15, 'inch'),
              y = unit(0.8, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
```

```{r results1-fig1-clean}
rm(list = str_subset(ls(), "fig1"))
```

```{r results1-fig1-options-reset, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE)
```


## Results 2 (Placeholder title) {#results-2}

```{r results2-text1}
#For code chunk navigation purposes
```

Using a common space constructed from the expression of `r length(genes)` homologous genes, we observed clusters of similarity between coarsely defined regions of the mouse and human brains. While the distribution of correlation values within these broad regions is relatively homogeneous, the data show hints of local variation among the finer regions that make up these clusters, suggesting that the set of homologous genes contains information about mouse-human matches on a finer scale (Figure 1, panel C). We proceeded to investigate whether we could enhance these finer regional matches by constructing a new set of variables from the original gene set. Our primary goal was to transform the initial gene space into a new common space that would improve the locality of mouse-human matches. However while we sought a transformation that would allow us to recapitulate known mouse-human neuroanatomical homologues, we also wanted to avoid directly encoding such homologies in the transformation. Using this information as part of the optimization process for the transformation would run the risk of driving the transformation towards mouse-human matches that are already known. While we are interested in being able to recover such matches, we are equally interested in identifying novel and unexpected associations between neuroanatomical regions in the mouse and human brains, e.g. one-to-many correspondences. Given these criteria, our approach to identifying an appropriate transformation was to train a multi-layer perceptron (MLP) classifier on the data from the AMBA. The classifier was tasked with predicting the 67 labels in our mouse atlas from the voxel-wise expression of the `r length(genes)` homologous genes (Figure 2, panel A). While the model could have been trained using the data from either species, we chose to use the AMBA because it provides continuous coverage of the entire brain and is thus better suited to this purpose. In training the MLP to perform this classification task, we effectively optimize the network architecture to identify a transformation from the input gene space to a space that encodes information about the delineation between mouse brain regions. To extract this transformation, we removed the final predictive layer from the trained neural network. The resulting architecture defines a transformation from the input gene space to a lower-dimensional gene expression latent space. We then applied this transformation to the mouse and human gene expression blueprints to obtain representations of the data in the latent space (Figure 2, panel B). Finally, we used these gene expression latent space blueprints to compute the new similarity matrix (Figure 2, panel C). Since the algorithm used to train the MLP features an inherent degree of stochasticity, we repeated this training and transformation process 500 times to generate a distribution of latent spaces and similarity matrices over training runs.

```{r results2-fig2-processing}
#Files containing latent space representations
filesMLP_Mouse <- list.files("../../../data/MLP_outcomes/", pattern = "MouseTx", full.names = T)
filesMLP_Human <- list.files("../../../data/MLP_outcomes/", pattern = "HumanTx", full.names = T)

#Import the mouse latent space data
listMouseLatentSpace <- map(filesMLP_Mouse,
                            function(x){
                              suppressMessages(read_csv(x)) %>% 
                                column_to_rownames("Region") %>% 
                                as.matrix() %>% 
                                t()
                            })

#Import the human latent space data
listHumanLatentSpace <- map(filesMLP_Human,
                            function(x){
                              suppressMessages(read_csv(x)) %>% 
                                column_to_rownames("Region") %>% 
                                as.matrix() %>% 
                                t()
                            })

#Compute the latent space similarity matrices
listSimLatentSpace <- map2(listHumanLatentSpace, listMouseLatentSpace,
                           function(x1, x2){
                             m <- buildSimilarityMatrix(x1 = x1, x2 = x2)
                             m <- m[,match(listLabelsMouseReordered$Region67_reordered, colnames(m))]
                             m <- m[match(listLabelsHumanReordered$Region88_reordered, rownames(m)),]
                           })
names(listSimLatentSpace) <- str_c("MLP_v", 1:length(listSimLatentSpace))
rm(listMouseLatentSpace, listHumanLatentSpace)
```

```{r results2-fig2-panelC-heatmap}
# Figure 2: Heatmap processing ------------------------------------------------

#To create an average similarity matrix, first concat the matrices into a 3D array
arraySimLatentSpace <- array(unlist(listSimLatentSpace),
                             dim = c(length(listLabelsHumanReordered$Region88_reordered),
                                     length(listLabelsMouseReordered$Region67_reordered),
                                     length(listSimLatentSpace)))

#Compute the average matrix
matSim_H88M67_MLP_mean <- rowMeans(arraySimLatentSpace, dims = 2)
rownames(matSim_H88M67_MLP_mean) <- listLabelsHumanReordered$Region88_reordered
colnames(matSim_H88M67_MLP_mean) <- listLabelsMouseReordered$Region67_reordered



# Figure 2: Heatmap base ggplot -----------------------------------------------

#Generate similarity matrix heatmap and convert to ggplot object
fig2_heatmap_ggplot <- pheatmap(matSim_H88M67_MLP_mean,
                                cluster_cols = F, cluster_rows = F,
                                border_color = NA,
                                show_rownames = F, show_colnames = F,
                                annotation_row = dfAnnotationHuman,
                                annotation_col = dfAnnotationMouse,
                                annotation_colors = annotation_colours,
                                legend = F,
                                annotation_legend = F,
                                annotation_names_col = F, annotation_names_row = F) %>% 
  as.ggplot()



# Figure 2: Heatmap matrix ----------------------------------------------------

#Convert the pheatmap plot to grob and force the gTree
fig2_heatmap_main_grob <- ggplotGrob(fig2_heatmap_ggplot) %>% grid.force()

#Extract the matrix grob from the plot
fig2_heatmap_main_matrix_grob <- fig2_heatmap_main_grob %>% 
  getGrob("matrix.4-3-4-3") 

#Extract the row annotations and reposition them
# fig2_heatmap_main_rowannotations_grob <- fig2_heatmap_main_grob %>% 
#   getGrob("row_annotation.4-2-4-2") %>%
#   editGrob(x = unit(0.1,'npc'),
#            width = unit(0.9, 'npc'),
#            just = "left")
fig2_heatmap_main_rowannotations_grob <- fig2_heatmap_main_grob %>% 
  getGrob("row_annotation.4-2-4-2") %>%
  editGrob(x = unit(0,'npc'),
           width = unit(0.9, 'npc'),
           just = "left")

#Exract the column annotations and reposition them
fig2_heatmap_main_colannotations_grob <- fig2_heatmap_main_grob %>% 
  getGrob("col_annotation.3-3-3-3") %>% 
  editGrob(y = unit(0.1, 'npc'),
           height = unit(0.9, 'npc'),
           just = "bottom")

#Recombine the plot into a single grob layout
#Annotation sizes are fixed in inches. Matrix fills the remaining space
# fig2_heatmap_main_grob <- arrangeGrob(fig2_heatmap_main_colannotations_grob, 
#                                       fig2_heatmap_main_rowannotations_grob,
#                                       fig2_heatmap_main_matrix_grob,
#                                       layout_matrix = rbind(c(1, NA),
#                                                             c(3,  2)),
#                                       widths = unit(c(0.9, 0.1), c('null', 'inch')),
#                                       heights = unit(c(0.1, 0.9), c('inch', 'null')))
fig2_heatmap_main_grob <- arrangeGrob(fig2_heatmap_main_colannotations_grob, 
                                      fig2_heatmap_main_rowannotations_grob,
                                      fig2_heatmap_main_matrix_grob,
                                      layout_matrix = rbind(c(NA, 1),
                                                            c( 2, 3)),
                                      widths = unit(c(0.1, 0.9), c('inch', 'null')),
                                      heights = unit(c(0.1, 0.9), c('inch', 'null')))



# Figure 2: Heatmap legend ----------------------------------------------------

#1. Legend scale
#Generate the legend palette
fig2_heatmap_legend_palette <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100) %>%
  matrix(nrow = 1, ncol = 100)

#Properties for the legend scale
fig2_heatmap_legend_scale_width <- 1  #Width
fig2_heatmap_legend_scale_height <- 0.2 #Height
fig2_heatmap_legend_scale_x <- 0        #x
fig2_heatmap_legend_scale_y <- 0.95     #y

#Create the raster grob for the legend scale
fig2_heatmap_legend_scale_grob <- rasterGrob(fig2_heatmap_legend_palette,
                                             x = fig2_heatmap_legend_scale_x,
                                             y = fig2_heatmap_legend_scale_y,
                                             width = fig2_heatmap_legend_scale_width,
                                             height = fig2_heatmap_legend_scale_height,
                                             just = c("left", "top"))

#2. Legend text
#Properties for legend text
fig2_heatmap_legend_text_min <- min(matSim_H88M67_MLP_mean)
fig2_heatmap_legend_text_max <- max(matSim_H88M67_MLP_mean)
fig2_heatmap_legend_text_nlabels <- 5

#Legend text is defined as a sequence from min to max
fig2_heatmap_legend_text_seq <- seq(fig2_heatmap_legend_text_min,
                                    fig2_heatmap_legend_text_max,
                                    length.out = fig2_heatmap_legend_text_nlabels) %>%
  round(2) %>%
  as.character()

#Legend text x and y positions are based on the raster's positions and dimensions
fig2_heatmap_legend_text_x <- seq(fig2_heatmap_legend_scale_x,
                                  fig2_heatmap_legend_scale_width,
                                  length.out = fig2_heatmap_legend_text_nlabels)
fig2_heatmap_legend_text_y <- fig2_heatmap_legend_scale_y - fig2_heatmap_legend_scale_height - 0.05

#Create the text grob for the legend text
fig2_heatmap_legend_text_grob <- textGrob(fig2_heatmap_legend_text_seq,
                                          x = fig2_heatmap_legend_text_x,
                                          y = fig2_heatmap_legend_text_y,
                                          just = c("center", "top"),
                                          gp = gpar(fontsize = 10))

#3. Legend title
#Properties for the legend title
fig2_heatmap_legend_title <- "Correlation"
fig2_heatmap_legend_title_x <- (fig2_heatmap_legend_scale_x + fig2_heatmap_legend_scale_width)/2
fig2_heatmap_legend_title_y <- fig2_heatmap_legend_text_y - 0.2

#Create the legend title grob
fig2_heatmap_legend_title_grob <- textGrob(fig2_heatmap_legend_title,
                                           x = fig2_heatmap_legend_title_x,
                                           y = fig2_heatmap_legend_title_y,
                                           just = c("center", "top"),
                                           gp = gpar(fontsize = 12))

#Combine the scale, text and title into a single grob
fig2_heatmap_legend_grob <- gTree(children = gList(fig2_heatmap_legend_scale_grob,
                                                   fig2_heatmap_legend_text_grob,
                                                   fig2_heatmap_legend_title_grob))



# Figure 2: Heatmap mouse labels ----------------------------------------------

#1. Mouse label text
#The mouse labels are acronyms for 11 coarse regions
fig2_heatmap_labsmouse_text <- treeMouse_11$Get("acronym", filterFun = isLeaf) %>% 
  enframe(name = "Region",
          value = "Acronym") %>% 
  mutate(Region = factor(Region, levels = listLabelsMouseReordered$Region11_reordered)) %>% 
  arrange(Region) %>% 
  pull(Acronym) %>% 
  as.character()

#Mouse label x positions
fig2_heatmap_labsmouse_text_x <- c(0.160, #Cortical subplate
                                   0.338, #Olfactory areas
                                   0.665, #Hippocampal formation
                                   1.199, #Isocortex
                                   1.704, #Cerebral nuclei
                                   1.852, #Interbrain
                                   2.001, #Midbrain
                                   2.149, #Pons
                                   2.297, #Medulla
                                   2.505, #Cerebellar cortex
                                   2.773) #Cerebellar nuclei

#Mouse label y positions are organized in two rows
fig2_heatmap_labsmouse_text_y <- rep(c(0.3,0.125), length.out = length(fig2_heatmap_labsmouse_text))

#Colours for the mouse labels
fig2_heatmap_labsmouse_text_col <- annotation_colours_mod$MouseRegion

#Create the text grob for the mouse labels
fig2_heatmap_labsmouse_text_grob <- textGrob(fig2_heatmap_labsmouse_text,
                                             x = unit(fig2_heatmap_labsmouse_text_x, 'inch'),
                                             y = unit(fig2_heatmap_labsmouse_text_y, 'inch'),
                                             just = "centre",
                                             gp = gpar(fontsize = 8, 
                                                       col = fig2_heatmap_labsmouse_text_col,
                                                       fontface = "bold"))

#2. Mouse label lines
#Positions of the lines are dependent on text positions
fig2_heatmap_labsmouse_line_x0 <- fig2_heatmap_labsmouse_text_x + c(-0.078, #Cortical subplate
                                                                    NA, #Olfactory areas
                                                                    0, #Hippocampal formation
                                                                    NA, #Isocortex
                                                                    0, #Cerebral nuclei
                                                                    NA, #Interbrain
                                                                    0, #Midbrain
                                                                    NA, #Pons
                                                                    -0.115, #Medulla
                                                                    NA, #Cerebellar cortex
                                                                    0.078) #Cerebellar nuclei
fig2_heatmap_labsmouse_line_x1 <- fig2_heatmap_labsmouse_line_x0 + c(0, #Cortical subplate
                                                                     0, #Olfactory areas
                                                                     0, #Hippocampal formation
                                                                     0, #Isocortex
                                                                     0, #Cerebral nuclei
                                                                     0, #Interbrain
                                                                     0, #Midbrain
                                                                     0, #Pons
                                                                     0.115, #Medulla
                                                                     0, #Cerebellar cortex
                                                                     0) #Cerebellar nuclei
fig2_heatmap_labsmouse_line_y0 <- rep(0, length.out = length(fig2_heatmap_labsmouse_text))
fig2_heatmap_labsmouse_line_y1 <- fig2_heatmap_labsmouse_text_y - 0.08

#Create the mouse label line grob
fig2_heatmap_labsmouse_line_grob <- segmentsGrob(x0 = unit(fig2_heatmap_labsmouse_line_x0, 'inch'),
                                                 x1 = unit(fig2_heatmap_labsmouse_line_x1, 'inch'),
                                                 y0 = unit(fig2_heatmap_labsmouse_line_y0, 'inch'),
                                                 y1 = unit(fig2_heatmap_labsmouse_line_y1, 'inch'),
                                                 gp = gpar(col = annotation_colours$MouseRegion,
                                                           lwd = 1))

#3. Mouse label title
fig2_heatmap_labsmouse_title_grob <- textGrob("Mouse regions",
                                              x = 0.5, 
                                              y = unit(0, 'npc'),
                                              just = "bottom")

#Combine the mouse label grobs into one
fig2_heatmap_labsmouse_grob <- gTree(children = gList(fig2_heatmap_labsmouse_text_grob,
                                                      fig2_heatmap_labsmouse_line_grob))



# Figure 2: Heatmap human labels ----------------------------------------------
#1. Human label text
fig2_heatmap_labshuman_text <- treeHuman_16$Get("acronym", filterFun = isLeaf) %>% 
  enframe(name = "Region",
          value = "Acronym") %>% 
  mutate(Region = factor(Region, levels = listLabelsHumanReordered$Region16_reordered)) %>% 
  arrange(Region) %>% 
  pull(Acronym) %>% 
  as.character()

# fig2_heatmap_labshuman_text_x <- rep(0.1, length.out = length(fig2_heatmap_labshuman_text))
fig2_heatmap_labshuman_text_x <- rep(0.9, length.out = length(fig2_heatmap_labshuman_text))
fig2_heatmap_labshuman_text_y <- c(3.783, #Claustrum
                                   3.588, #Limbic lobe
                                   3.081, #Frontal lobe
                                   2.672, #Insula
                                   2.516, #Occipital lobe
                                   2.301, #Parietal lobe
                                   1.950, #Temporal lobe
                                   1.775, #Amygdala
                                   1.638, #Basal ganglia
                                   1.521, #Basal forebrain
                                   1.385, #Diencephalon
                                   1.209, #Mesencephalon
                                   1.100, #Pons,
                                   0.975, #Myelencephalon,
                                   0.585, #Cerebellar cortex,
                                   0.039) #Cerebellar nuclei
fig2_heatmap_labshuman_text_col <- annotation_colours_mod$HumanRegion
# fig2_heatmap_labshuman_text_grob <- textGrob(fig2_heatmap_labshuman_text,
#                                              x = unit(fig2_heatmap_labshuman_text_x, 'inch'),
#                                              y = unit(fig2_heatmap_labshuman_text_y, 'inch'),
#                                              just = c("left", "centre"),
#                                              gp = gpar(fontsize = 8,
#                                                        fontface = "bold",
#                                                        col = fig2_heatmap_labshuman_text_col))
fig2_heatmap_labshuman_text_grob <- textGrob(fig2_heatmap_labshuman_text,
                                             x = unit(fig2_heatmap_labshuman_text_x, 'npc'),
                                             y = unit(fig2_heatmap_labshuman_text_y, 'inch'),
                                             just = c("right", "centre"),
                                             gp = gpar(fontsize = 8,
                                                       fontface = "bold",
                                                       col = fig2_heatmap_labshuman_text_col))

#2. Human label lines
# Only need a line for the myelencephalon
# fig2_heatmap_labshuman_line_grob <- segmentsGrob(x0 = 0.1, x1 = 0,
#                                                  y0 = 0.25, y1 = 0.27,
#                                                  gp = gpar(col = annotation_colours$HumanRegion[[14]],
#                                                            lwd = 1))
fig2_heatmap_labshuman_line_grob <- segmentsGrob(x0 = 0.9, x1 = 1,
                                                 y0 = 0.25, y1 = 0.27,
                                                 gp = gpar(col = annotation_colours$HumanRegion[[14]],
                                                           lwd = 1))

#3. Human label title
# fig2_heatmap_labshuman_title_grob <- textGrob("Human regions",
#                                               x = 0.5, y = 0.5,
#                                               rot = 270)
fig2_heatmap_labshuman_title_grob <- textGrob("Human regions",
                                              x = 0.5, y = 0.5,
                                              rot = 90)

#Combine the human label grobs into one
fig2_heatmap_labshuman_grob <- gTree(children = gList(fig2_heatmap_labshuman_text_grob,
                                                      fig2_heatmap_labshuman_line_grob))
```

```{r results2-fig2-panelA-illustration1}
# Figure 2: Illustration 1 network architecture -------------------------------

# Parameters
fig2_illustration1_neuralnet_nodes_xcentre <- 0.52
fig2_illustration1_neuralnet_nodes_ycentre <- 0.5
fig2_illustration1_neuralnet_nodes_lyrwidth <- 0.125
fig2_illustration1_neuralnet_nodes_height <- 0.65
fig2_illustration1_neuralnet_nodes_r <- 0.04

# 1. Neural network nodes
#Layer 1 x and y
fig2_illustration1_neuralnet_nodes_lyr1_x <- rep(fig2_illustration1_neuralnet_nodes_xcentre - 1.5*fig2_illustration1_neuralnet_nodes_lyrwidth, 5)
fig2_illustration1_neuralnet_nodes_lyr1_ystart <- fig2_illustration1_neuralnet_nodes_ycentre - fig2_illustration1_neuralnet_nodes_height/2
fig2_illustration1_neuralnet_nodes_lyr1_yend <- fig2_illustration1_neuralnet_nodes_ycentre + fig2_illustration1_neuralnet_nodes_height/2
fig2_illustration1_neuralnet_nodes_lyr1_y <- seq(fig2_illustration1_neuralnet_nodes_lyr1_ystart, 
                                                 fig2_illustration1_neuralnet_nodes_lyr1_yend,
                                                 length.out = 5)
#Layer 2 x and y
fig2_illustration1_neuralnet_nodes_lyr2_x <- rep(fig2_illustration1_neuralnet_nodes_xcentre - 0.5*fig2_illustration1_neuralnet_nodes_lyrwidth, 3)
fig2_illustration1_neuralnet_nodes_lyr2_y <- fig2_illustration1_neuralnet_nodes_lyr1_y[2:4]

#Layer 3 x and y
fig2_illustration1_neuralnet_nodes_lyr3_x <- rep(fig2_illustration1_neuralnet_nodes_xcentre + 0.5*fig2_illustration1_neuralnet_nodes_lyrwidth, 3)
fig2_illustration1_neuralnet_nodes_lyr3_y <- fig2_illustration1_neuralnet_nodes_lyr2_y

#Layer 4 x and y
fig2_illustration1_neuralnet_nodes_lyr4_x <- rep(fig2_illustration1_neuralnet_nodes_xcentre + 1.5*fig2_illustration1_neuralnet_nodes_lyrwidth, 4)
fig2_illustration1_neuralnet_nodes_lyr4_ystart <- mean(c(fig2_illustration1_neuralnet_nodes_lyr1_y[1],
                                                         fig2_illustration1_neuralnet_nodes_lyr1_y[2]))
fig2_illustration1_neuralnet_nodes_lyr4_yend <- mean(c(fig2_illustration1_neuralnet_nodes_lyr1_y[length(fig2_illustration1_neuralnet_nodes_lyr1_y)],
                                                       fig2_illustration1_neuralnet_nodes_lyr1_y[length(fig2_illustration1_neuralnet_nodes_lyr1_y)-1]))
fig2_illustration1_neuralnet_nodes_lyr4_y <- seq(fig2_illustration1_neuralnet_nodes_lyr4_ystart,
                                                 fig2_illustration1_neuralnet_nodes_lyr4_yend,
                                                 length.out = 4)

#Combine nodes x and y positions
fig2_illustration1_neuralnet_nodes_x <- c(fig2_illustration1_neuralnet_nodes_lyr1_x,
                                          fig2_illustration1_neuralnet_nodes_lyr2_x,
                                          fig2_illustration1_neuralnet_nodes_lyr3_x,
                                          fig2_illustration1_neuralnet_nodes_lyr4_x)
fig2_illustration1_neuralnet_nodes_y <- c(fig2_illustration1_neuralnet_nodes_lyr1_y,
                                          fig2_illustration1_neuralnet_nodes_lyr2_y,
                                          fig2_illustration1_neuralnet_nodes_lyr3_y,
                                          fig2_illustration1_neuralnet_nodes_lyr4_y)

#Generate circle grobs for nodes
fig2_illustration1_neuralnet_nodes_grob <- circleGrob(x = fig2_illustration1_neuralnet_nodes_x, 
                                                      y = fig2_illustration1_neuralnet_nodes_y,
                                                      r = fig2_illustration1_neuralnet_nodes_r,
                                                      gp = gpar(fill = "#719DC0",
                                                                col = "#00325C"))

#2. Neural net weights
#Line start/end points for 1st layer
fig2_illustration1_neuralnet_weights_12 <- expand.grid(fig2_illustration1_neuralnet_nodes_lyr1_y,
                                                       fig2_illustration1_neuralnet_nodes_lyr2_y) %>% 
  mutate(y0 = Var1,
         y1 = Var2,
         x0 = unique(fig2_illustration1_neuralnet_nodes_lyr1_x),
         x1 = unique(fig2_illustration1_neuralnet_nodes_lyr2_x))

#Line start/end points for 2nd layer
fig2_illustration1_neuralnet_weights_23 <- expand.grid(fig2_illustration1_neuralnet_nodes_lyr2_y,
                                                       fig2_illustration1_neuralnet_nodes_lyr3_y) %>% 
  mutate(y0 = Var1,
         y1 = Var2,
         x0 = unique(fig2_illustration1_neuralnet_nodes_lyr2_x),
         x1 = unique(fig2_illustration1_neuralnet_nodes_lyr3_x))

#Line start/end points for 3rd layer
fig2_illustration1_neuralnet_weights_34 <- expand.grid(fig2_illustration1_neuralnet_nodes_lyr3_y,
                                                       fig2_illustration1_neuralnet_nodes_lyr4_y) %>% 
  mutate(y0 = Var1,
         y1 = Var2,
         x0 = unique(fig2_illustration1_neuralnet_nodes_lyr3_x),
         x1 = unique(fig2_illustration1_neuralnet_nodes_lyr4_x))

#Combine line points together
fig2_illustration1_neuralnet_weights <- rbind(fig2_illustration1_neuralnet_weights_12,
                                              fig2_illustration1_neuralnet_weights_23,
                                              fig2_illustration1_neuralnet_weights_34)

#Create segments grob for all weights lines
fig2_illustration1_neuralnet_weights_grob <- segmentsGrob(x0 = fig2_illustration1_neuralnet_weights$x0,
                                                          x1 = fig2_illustration1_neuralnet_weights$x1,
                                                          y0 = fig2_illustration1_neuralnet_weights$y0,
                                                          y1 = fig2_illustration1_neuralnet_weights$y1,
                                                          gp = gpar(lty = "dashed",
                                                                    col = "#B27700"))

#3. Neural net annotations
fig2_illustration1_neuralnet_annotations <- c("Input", "Hidden layers", "Output")
fig2_illustration1_neuralnet_annotation_x <- c(unique(fig2_illustration1_neuralnet_nodes_lyr1_x),
                                               fig2_illustration1_neuralnet_nodes_xcentre,
                                               unique(fig2_illustration1_neuralnet_nodes_lyr4_x))
fig2_illustration1_neuralnet_annotation_y <- c(fig2_illustration1_neuralnet_nodes_lyr1_yend,
                                               max(fig2_illustration1_neuralnet_nodes_lyr2_y),
                                               fig2_illustration1_neuralnet_nodes_lyr1_yend) + 0.1
fig2_illustration1_neuralnet_annotation_grob <- textGrob(fig2_illustration1_neuralnet_annotations,
                                                         x = fig2_illustration1_neuralnet_annotation_x,
                                                         y = fig2_illustration1_neuralnet_annotation_y)

fig2_illustration1_neuralnet_title_grob <- textGrob("Untrained network",
                                                    x = fig2_illustration1_neuralnet_nodes_xcentre,
                                                    y = fig2_illustration1_neuralnet_nodes_lyr1_ystart)

#Combine neural network schematic into one grob
fig2_illustration1_neuralnet_grob <- gTree(children = gList(fig2_illustration1_neuralnet_weights_grob,
                                                            fig2_illustration1_neuralnet_nodes_grob,
                                                            fig2_illustration1_neuralnet_annotation_grob,
                                                            fig2_illustration1_neuralnet_title_grob))



#Figure 2: Illustration 1 network input ---------------------------------------

#1. Input labels
fig2_illustration1_input_labels_rect_x <- unique(fig2_illustration1_neuralnet_nodes_lyr1_x) - fig2_illustration1_neuralnet_nodes_r - 0.06
fig2_illustration1_input_labels_rect_y <- fig2_illustration1_neuralnet_nodes_ycentre
fig2_illustration1_input_labels_rect_width <- 0.03
fig2_illustration1_input_labels_rect_height <- fig2_illustration1_neuralnet_nodes_height - fig2_illustration1_neuralnet_nodes_r - 0.1
fig2_illustration1_input_labels_rect_grob <- rectGrob(x = fig2_illustration1_input_labels_rect_x,
                                                      y = fig2_illustration1_input_labels_rect_y,
                                                      just = "right",
                                                      width = fig2_illustration1_input_labels_rect_width, 
                                                      height = fig2_illustration1_input_labels_rect_height,
                                                      gp = gpar(fill = "#719DC0",
                                                                col = "#00325C"))

fig2_illustration1_input_labels_text_x <- fig2_illustration1_input_labels_rect_x - fig2_illustration1_input_labels_rect_width/2
fig2_illustration1_input_labels_text_y <- fig2_illustration1_input_labels_rect_y + fig2_illustration1_input_labels_rect_height/2 + 0.03
fig2_illustration1_input_labels_text_grob <- textGrob("True\nlabels",
                                                      x = fig2_illustration1_input_labels_text_x,
                                                      y = fig2_illustration1_input_labels_text_y,
                                                      just = "bottom",
                                                      gp = gpar(fontsize = 10,
                                                                lineheight = 0.75))

fig2_illustration1_input_labels_grob <- gTree(children = gList(fig2_illustration1_input_labels_rect_grob,
                                                               fig2_illustration1_input_labels_text_grob))


#2. Input data matrix
#2.1. Input data matrix rectangle
fig2_illustration1_input_data_rect_x <- fig2_illustration1_input_labels_rect_x - fig2_illustration1_input_labels_rect_width - 0.02
fig2_illustration1_input_data_rect_y <- fig2_illustration1_input_labels_rect_y
fig2_illustration1_input_data_rect_width <- 0.125
fig2_illustration1_input_data_rect_height <- fig2_illustration1_input_labels_rect_height
fig2_illustration1_input_data_rect_grob <- rectGrob(x = fig2_illustration1_input_data_rect_x,
                                                    y = fig2_illustration1_input_data_rect_y,
                                                    just = "right",
                                                    width = fig2_illustration1_input_data_rect_width, 
                                                    height = fig2_illustration1_input_data_rect_height,
                                                    gp = gpar(fill = "#719DC0",
                                                                col = "#00325C"))

#2.2. Input data matrix annotations
fig2_illustration1_input_data_text_xaxis_x <- fig2_illustration1_input_data_rect_x - fig2_illustration1_input_data_rect_width/2
fig2_illustration1_input_data_text_xaxis_y <- fig2_illustration1_input_data_rect_y + fig2_illustration1_input_data_rect_height/2 + 0.03
fig2_illustration1_input_data_text_xaxis_grob <- textGrob("Genes",
                                                          just = "bottom",
                                                          x = fig2_illustration1_input_data_text_xaxis_x,
                                                          y = fig2_illustration1_input_data_text_xaxis_y,
                                                          gp = gpar(fontsize = 10,
                                                                    lineheight = 0.75))

fig2_illustration1_input_data_text_yaxis_x <- fig2_illustration1_input_data_rect_x - fig2_illustration1_input_data_rect_width - 0.02
fig2_illustration1_input_data_text_yaxis_y <- fig2_illustration1_input_data_rect_y
fig2_illustration1_input_data_text_yaxis_grob <- textGrob("Voxels",
                                                          x = fig2_illustration1_input_data_text_yaxis_x,
                                                          y = fig2_illustration1_input_data_text_yaxis_y,
                                                          rot = 90,
                                                          gp = gpar(fontsize = 10))

fig2_illustration1_input_data_text_title_x <- mean(c(fig2_illustration1_input_labels_rect_x,
                                                     fig2_illustration1_input_data_rect_x - fig2_illustration1_input_data_rect_width))
fig2_illustration1_input_data_text_title_y <- fig2_illustration1_neuralnet_nodes_lyr1_ystart
fig2_illustration1_input_data_text_title_grob <- textGrob("Mouse voxel data",
                                                          x = fig2_illustration1_input_data_text_title_x,
                                                          y = fig2_illustration1_input_data_text_title_y)

fig2_illustration1_input_data_grob <- gTree(children = gList(fig2_illustration1_input_data_rect_grob,
                                                             fig2_illustration1_input_data_text_xaxis_grob,
                                                             fig2_illustration1_input_data_text_yaxis_grob,
                                                             fig2_illustration1_input_data_text_title_grob))



# Figure 2: Illustration 1 network output -------------------------------------

#1. Loss function text
fig2_illustration1_output_loss_text_xstart <- unique(fig2_illustration1_neuralnet_nodes_lyr4_x) + fig2_illustration1_neuralnet_nodes_r + 0.06
fig2_illustration1_output_loss_text_xend <- 0.98
fig2_illustration1_output_loss_text_xseq <- seq(fig2_illustration1_output_loss_text_xstart + 0.04,
                                                fig2_illustration1_output_loss_text_xend,
                                                length.out = 3)
fig2_illustration1_output_loss_text_x <- c(fig2_illustration1_output_loss_text_xstart, fig2_illustration1_output_loss_text_xseq)
fig2_illustration1_output_loss_text_y <- fig2_illustration1_input_labels_rect_y
fig2_illustration1_output_loss_text_grob <- textGrob(c("L", "(", ",", ")"),
                                                     x = fig2_illustration1_output_loss_text_x,
                                                     y = fig2_illustration1_output_loss_text_y,
                                                     gp = gpar(fontsize = 24))

#2. Output labels
fig2_illustration1_output_labels_rect_x <- c(mean(fig2_illustration1_output_loss_text_x[2:3]),
                                             mean(fig2_illustration1_output_loss_text_x[3:4]))
fig2_illustration1_output_labels_rect_y <- fig2_illustration1_input_labels_rect_y
fig2_illustration1_output_labels_rect_width <- fig2_illustration1_input_labels_rect_width
fig2_illustration1_output_labels_rect_height <- fig2_illustration1_input_labels_rect_height
fig2_illustration1_output_labels_grob <- rectGrob(x = fig2_illustration1_output_labels_rect_x,
                                                  y = fig2_illustration1_output_labels_rect_y,
                                                  width = fig2_illustration1_output_labels_rect_width,
                                                  height = fig2_illustration1_output_labels_rect_height,
                                                  gp = gpar(fill = "#719DC0",
                                                            col = "#00325C"))

#3. Output annotations
fig2_illustration1_output_text_x <- fig2_illustration1_output_labels_rect_x + c(-0.01, 0.01)
fig2_illustration1_output_text_y <- fig2_illustration1_output_labels_rect_y + fig2_illustration1_output_labels_rect_height/2 + 0.03
fig2_illustration1_output_text <- c("True\nlabels", "Predicted\nlabels")
fig2_illustration1_output_text_grob <- textGrob(fig2_illustration1_output_text,
                                                x = fig2_illustration1_output_text_x,
                                                y = fig2_illustration1_output_text_y,
                                                just = "bottom",
                                                gp = gpar(fontsize = 10,
                                                          lineheight = 0.75))

fig2_illustration1_output_title_x <- mean(c(fig2_illustration1_output_loss_text_xstart,
                                            fig2_illustration1_output_loss_text_xend))
fig2_illustration1_output_title_y <- fig2_illustration1_neuralnet_nodes_lyr1_ystart
fig2_illustration1_output_title_grob <- textGrob("Objective function",
                                                 x = fig2_illustration1_output_title_x,
                                                 y = fig2_illustration1_output_title_y)

fig2_illustration1_output_grob <- gTree(children = gList(fig2_illustration1_output_loss_text_grob,
                                                         fig2_illustration1_output_labels_grob,
                                                         fig2_illustration1_output_text_grob,
                                                         fig2_illustration1_output_title_grob))



# Figure 2: Illustration 1 arrows ---------------------------------------------

fig2_illustration1_arrows_x0 <- rep(fig2_illustration1_neuralnet_nodes_lyr1_x, 2) - 0.05
fig2_illustration1_arrows_x1 <- rep(fig2_illustration1_neuralnet_nodes_lyr4_x, 2) + 0.05
fig2_illustration1_arrows_y0 <- fig2_illustration1_neuralnet_nodes_lyr4_y[2:3]
fig2_illustration1_arrows_y1 <- fig2_illustration1_neuralnet_nodes_lyr4_y[2:3] 
fig2_illustration1_arrows_grob <- segmentsGrob(x0 = fig2_illustration1_arrows_x0,
                                               x1 = fig2_illustration1_arrows_x1,
                                               y0 = fig2_illustration1_arrows_y0,
                                               y1 = fig2_illustration1_arrows_y1,
                                               arrow = arrow(angle = 30,
                                                             length = unit(0.05, 'npc'),
                                                             type = "closed",
                                                             ends = c("last", "first")),
                                               gp = gpar(lwd = 3, fill = "black"))

#Fig 2 illustration 1 grob
fig2_illustration1_grob <- gTree(children = gList(fig2_illustration1_input_data_grob,
                                                  fig2_illustration1_input_labels_grob,
                                                  fig2_illustration1_neuralnet_grob,
                                                  fig2_illustration1_output_grob,
                                                  fig2_illustration1_arrows_grob))
```

```{r results2-fig2-panelB-illustration2}
# Figure 2: Illustration 2 network architecture -------------------------------

#1. Neural net nodes
fig2_illustration2_neuralnet_nodes_x <- fig2_illustration1_neuralnet_nodes_x
fig2_illustration2_neuralnet_nodes_y <- fig2_illustration1_neuralnet_nodes_y
ind_lyr4 <- fig2_illustration2_neuralnet_nodes_x == unique(fig2_illustration1_neuralnet_nodes_lyr4_x)
fig2_illustration2_neuralnet_nodes_alpha <- rep(1, length(fig2_illustration2_neuralnet_nodes_x))
fig2_illustration2_neuralnet_nodes_alpha[ind_lyr4] <- 0.2

#Generate circle grobs for nodes
fig2_illustration2_neuralnet_nodes_grob <- circleGrob(x = fig2_illustration2_neuralnet_nodes_x, 
                                                      y = fig2_illustration2_neuralnet_nodes_y,
                                                      r = fig2_illustration1_neuralnet_nodes_r,
                                                      gp = gpar(alpha = fig2_illustration2_neuralnet_nodes_alpha,
                                                                fill = "#719DC0",
                                                                col = "#00325C"))

#2. Neural net weights
#Combine line points together
fig2_illustration2_neuralnet_weights <- fig2_illustration1_neuralnet_weights
ind_lyr4 <- fig2_illustration2_neuralnet_weights$x1 == unique(fig2_illustration1_neuralnet_nodes_lyr4_x)
fig2_illustration2_neuralnet_weights_alpha <- rep(1, nrow(fig2_illustration2_neuralnet_weights))
fig2_illustration2_neuralnet_weights_alpha[ind_lyr4] <- 0.2

#Create segments grob for all weights lines
fig2_illustration2_neuralnet_weights_grob <- segmentsGrob(x0 = fig2_illustration2_neuralnet_weights$x0,
                                                          x1 = fig2_illustration2_neuralnet_weights$x1,
                                                          y0 = fig2_illustration2_neuralnet_weights$y0,
                                                          y1 = fig2_illustration2_neuralnet_weights$y1,
                                                          gp = gpar(alpha = fig2_illustration2_neuralnet_weights_alpha,
                                                                    col = "#B27700"))

#3. Neural net annotations
fig2_illustration2_neuralnet_title_grob <- textGrob("Trained network",
                                                    x = fig2_illustration1_neuralnet_nodes_xcentre,
                                                    y = min(fig2_illustration2_neuralnet_nodes_y))

fig2_illustration2_neuralnet_grob <- gTree(children = gList(fig2_illustration2_neuralnet_weights_grob,
                                                            fig2_illustration2_neuralnet_nodes_grob,
                                                            fig2_illustration2_neuralnet_title_grob))



#Figure 2: Illustration 2 network input ---------------------------------------

#Data rectangles
fig2_illustration2_input_rect_x <- min(fig2_illustration2_neuralnet_nodes_x) - 0.12
fig2_illustration2_input_rect_y <- fig2_illustration1_neuralnet_nodes_ycentre + c(-0.2, 0.2)
fig2_illustration2_input_rect_width <- fig2_illustration1_input_data_rect_width
fig2_illustration2_input_rect_height <- 0.2
fig2_illustration2_input_rect_grob <- rectGrob(x = fig2_illustration2_input_rect_x,
                                               y = fig2_illustration2_input_rect_y,
                                               just = "right",
                                               width = fig2_illustration2_input_rect_width,
                                               height = fig2_illustration2_input_rect_height,
                                               gp = gpar(col = c("#B27700", "#00325C"),
                                                         fill = c("#D8BD8A", "#719DC0")))

#
fig2_illustration2_input_text_xaxis_x <- fig2_illustration2_input_rect_x - fig2_illustration2_input_rect_width/2 
fig2_illustration2_input_text_xaxis_y <- fig2_illustration2_input_rect_y + fig2_illustration2_input_rect_height/2 + 0.03
fig2_illustration2_input_text_xaxis_grob <- textGrob("Genes",
                                                     x = fig2_illustration2_input_text_xaxis_x,
                                                     y = fig2_illustration2_input_text_xaxis_y,
                                                     gp = gpar(fontsize = 10))

fig2_illustration2_input_text_yaxis_x <- fig2_illustration2_input_rect_x - fig2_illustration2_input_rect_width - 0.02
fig2_illustration2_input_text_yaxis_y <- fig2_illustration2_input_rect_y
fig2_illustration2_input_text_yaxis_grob <- textGrob("ROIs",
                                                     x = fig2_illustration2_input_text_yaxis_x,
                                                     y = fig2_illustration2_input_text_yaxis_y,
                                                     rot = 90,
                                                     gp = gpar(fontsize = 10))

fig2_illustration2_input_text_title <- c("Human data", "Mouse data")
fig2_illustration2_input_text_title_x <- mean(c(fig2_illustration2_input_rect_x,
                                                fig2_illustration2_input_rect_x - fig2_illustration2_input_rect_width))
fig2_illustration2_input_text_title_y <- fig2_illustration2_input_rect_y - fig2_illustration2_input_rect_height/2 - 0.05
fig2_illustration2_input_text_title_grob <- textGrob(fig2_illustration2_input_text_title,
                                                     x = fig2_illustration2_input_text_title_x,
                                                     y = fig2_illustration2_input_text_title_y)

fig2_illustration2_input_grob <- gTree(children = gList(fig2_illustration2_input_rect_grob,
                                                        fig2_illustration2_input_text_xaxis_grob,
                                                        fig2_illustration2_input_text_yaxis_grob,
                                                        fig2_illustration2_input_text_title_grob))



#Figure 2: Illustration 2 network output --------------------------------------
#Data rectangles
fig2_illustration2_output_rect_x <- max(fig2_illustration2_neuralnet_nodes_x) + 0.12
fig2_illustration2_output_rect_y <- fig2_illustration2_input_rect_y
fig2_illustration2_output_rect_width <- fig2_illustration2_input_rect_width
fig2_illustration2_output_rect_height <- fig2_illustration2_input_rect_height
fig2_illustration2_output_rect_grob <- rectGrob(x = fig2_illustration2_output_rect_x,
                                                y = fig2_illustration2_output_rect_y,
                                                just = "left",
                                                width = fig2_illustration2_output_rect_width,
                                                height = fig2_illustration2_output_rect_height,
                                                gp = gpar(col = c("#B27700", "#00325C"),
                                                         fill = c("#D8BD8A", "#719DC0")))

#
fig2_illustration2_output_text_xaxis_x <- fig2_illustration2_output_rect_x + fig2_illustration2_input_rect_width/2 
fig2_illustration2_output_text_xaxis_y <- fig2_illustration2_output_rect_y + fig2_illustration2_output_rect_height/2 + 0.03
fig2_illustration2_output_text_xaxis_grob <- textGrob("Hidden units",
                                                      x = fig2_illustration2_output_text_xaxis_x,
                                                      y = fig2_illustration2_output_text_xaxis_y,
                                                      gp = gpar(fontsize = 10))

fig2_illustration2_output_text_yaxis_x <- fig2_illustration2_output_rect_x - 0.02
fig2_illustration2_output_text_yaxis_y <- fig2_illustration2_output_rect_y
fig2_illustration2_output_text_yaxis_grob <- textGrob("ROIs",
                                                     x = fig2_illustration2_output_text_yaxis_x,
                                                     y = fig2_illustration2_output_text_yaxis_y,
                                                     rot = 90,
                                                     gp = gpar(fontsize = 10))

fig2_illustration2_output_grob <- gTree(children = gList(fig2_illustration2_output_rect_grob,
                                                         fig2_illustration2_output_text_xaxis_grob,
                                                         fig2_illustration2_output_text_yaxis_grob))



# Figure 2: Illustration 2 arrows ---------------------------------------------
fig2_illustration2_arrow1_segment1_x1 <- fig2_illustration2_input_rect_x + 0.05
fig2_illustration2_arrow1_segment1_x2 <- fig2_illustration1_neuralnet_nodes_xcentre
fig2_illustration2_arrow1_segment1_y1 <- min(fig2_illustration2_input_rect_y)
fig2_illustration2_arrow1_segment1_y2 <- fig2_illustration1_neuralnet_nodes_ycentre - 0.06

fig2_illustration2_arrow1_segment2_x1 <- fig2_illustration2_arrow1_segment1_x2
fig2_illustration2_arrow1_segment2_x2 <- fig2_illustration2_output_rect_x - 0.05
fig2_illustration2_arrow1_segment2_y1 <- fig2_illustration2_arrow1_segment1_y2
fig2_illustration2_arrow1_segment2_y2 <- min(fig2_illustration2_output_rect_y)

fig2_illustration2_arrow1_segment1_grob <- curveGrob(x1 = fig2_illustration2_arrow1_segment1_x1,
                                                     x2 = fig2_illustration2_arrow1_segment1_x2,
                                                     y1 = fig2_illustration2_arrow1_segment1_y1,
                                                     y2 = fig2_illustration2_arrow1_segment1_y2,
                                                     curvature = -0.1,
                                                     ncp = 8,
                                                     square = FALSE,
                                                     gp = gpar(lwd = 3, fill = "black"))
fig2_illustration2_arrow1_segment2_grob <- curveGrob(x1 = fig2_illustration2_arrow1_segment2_x1,
                                                     x2 = fig2_illustration2_arrow1_segment2_x2,
                                                     y1 = fig2_illustration2_arrow1_segment2_y1,
                                                     y2 = fig2_illustration2_arrow1_segment2_y2,
                                                     curvature = -0.1,
                                                     ncp = 8,
                                                     square = FALSE,
                                                     arrow = arrow(angle = 20,
                                                                   length = unit(0.05, 'npc'),
                                                                   type = "closed",
                                                                   ends = "last"),
                                                     gp = gpar(lwd = 3, fill = "black"))


fig2_illustration2_arrow2_segment1_x1 <- fig2_illustration2_input_rect_x + 0.05
fig2_illustration2_arrow2_segment1_x2 <- fig2_illustration1_neuralnet_nodes_xcentre
fig2_illustration2_arrow2_segment1_y1 <- max(fig2_illustration2_input_rect_y)
fig2_illustration2_arrow2_segment1_y2 <- fig2_illustration1_neuralnet_nodes_ycentre + 0.06

fig2_illustration2_arrow2_segment2_x1 <- fig2_illustration2_arrow2_segment1_x2
fig2_illustration2_arrow2_segment2_x2 <- fig2_illustration2_output_rect_x - 0.05
fig2_illustration2_arrow2_segment2_y1 <- fig2_illustration2_arrow2_segment1_y2
fig2_illustration2_arrow2_segment2_y2 <- max(fig2_illustration2_output_rect_y)

fig2_illustration2_arrow2_segment1_grob <- curveGrob(x1 = fig2_illustration2_arrow2_segment1_x1,
                                                     x2 = fig2_illustration2_arrow2_segment1_x2,
                                                     y1 = fig2_illustration2_arrow2_segment1_y1,
                                                     y2 = fig2_illustration2_arrow2_segment1_y2,
                                                     curvature = 0.1,
                                                     ncp = 8,
                                                     square = FALSE,
                                                     gp = gpar(lwd = 3, fill = "black"))
fig2_illustration2_arrow2_segment2_grob <- curveGrob(x1 = fig2_illustration2_arrow2_segment2_x1,
                                                     x2 = fig2_illustration2_arrow2_segment2_x2,
                                                     y1 = fig2_illustration2_arrow2_segment2_y1,
                                                     y2 = fig2_illustration2_arrow2_segment2_y2,
                                                     curvature = 0.1,
                                                     ncp = 8,
                                                     square = FALSE,
                                                     arrow = arrow(angle = 20,
                                                                   length = unit(0.05, 'npc'),
                                                                   type = "closed",
                                                                   ends = "last"),
                                                     gp = gpar(lwd = 3, fill = "black"))


fig2_illustration2_arrows_grob <- gTree(children = gList(fig2_illustration2_arrow1_segment1_grob,
                                                         fig2_illustration2_arrow1_segment2_grob,
                                                         fig2_illustration2_arrow2_segment1_grob,
                                                         fig2_illustration2_arrow2_segment2_grob))

fig2_illustration2_grob <- gTree(children = gList(fig2_illustration2_neuralnet_grob,
                                                  fig2_illustration2_input_grob,
                                                  fig2_illustration2_output_grob,
                                                  fig2_illustration2_arrows_grob))
```

```{r results2-fig2-grob}
#Heatmap aspect ratio, figure height and width
matAsp <- ncol(matSim_H88M67_MLP_mean)/nrow(matSim_H88M67_MLP_mean)
matHeight <- 3.9
matWidth <- matAsp*matHeight

#Grob for figure 2
# fig2_grob <- arrangeGrob(fig2_heatmap_main_grob, #1
#                          fig2_heatmap_labsmouse_grob, #2
#                          fig2_heatmap_labsmouse_title_grob, #3
#                          fig2_heatmap_labshuman_grob, #4
#                          fig2_heatmap_labshuman_title_grob, #5
#                          fig2_heatmap_legend_grob, #6
#                          fig2_illustration1_grob, #7
#                          fig2_illustration2_grob, #8
#                          layout_matrix = rbind(c(NA, NA,  3, NA, NA),
#                                                c( 7, NA,  2, NA, NA),
#                                                c( 7, NA,  1,  4,  5),
#                                                c( 8, NA,  1,  4,  5),
#                                                c( 8, NA,  6, NA, NA)),
#                          widths = unit(c(5.3, 0.7, matWidth, 0.5, 0.3), 'inch'),
#                          heights = unit(c(0.3, 0.5, matHeight/2, matHeight/2, 1), 'inch'))
fig2_grob <- arrangeGrob(fig2_heatmap_main_grob, #1
                         fig2_heatmap_labsmouse_grob, #2
                         fig2_heatmap_labsmouse_title_grob, #3
                         fig2_heatmap_labshuman_grob, #4
                         fig2_heatmap_labshuman_title_grob, #5
                         fig2_heatmap_legend_grob, #6
                         fig2_illustration1_grob, #7
                         fig2_illustration2_grob, #8
                         layout_matrix = rbind(c(NA, NA, NA, NA,  3, NA),
                                               c( 7, NA, NA, NA,  2, NA),
                                               c( 7, NA,  5,  4,  1, NA),
                                               c( 8, NA,  5,  4,  1, NA),
                                               c( 8, NA, NA, NA,  6, NA)),
                         widths = unit(c(5.3, 0.5, 0.3, 0.45, matWidth, 0.2), 'inch'),
                         heights = unit(c(0.3, 0.5, matHeight/2, matHeight/2, 1), 'inch'))
```

```{r results2-fig2-interactive, include=FALSE, echo = FALSE, fig.width=10, fig.height=5.8}
grid.newpage()
grid.draw(fig2_grob)
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.3, 0.3, 5.75), 'inch'),
          y = unit(c(5.5, 2.85, 5.5), 'inch'),
          gp = gpar(fontsize = 14,
                    fontface = "bold"))
grid.text(c("Training the MLP classifier", "Transforming the gene expression blueprints"),
          x = unit(rep(0.5, 2), 'inch'),
          y = unit(c(5.5, 2.85), 'inch'),
          just = "left",
          gp = gpar(fontsize = 14))
grid.rect(gp = gpar(fill = NA))
```

```{r results2-fig2-caption}
fig2_cap_A <- str_c("(A) Schematic illustrating how the MLP classifier was trained. Voxel-wise expression maps from", length(genes), "homologous genes in the AMBA were used to train the neural network to classify each mouse voxel into one of 67 atlas regions. Blue circles represent hidden units or neurons in the network while golden dashed lines represent the connections or weights between units in different layers. The network generates predicted labels from the input data (black arrow pointing forwards), which are then passed to an objective function to evaluate the network's performance. This information is propagated backwards through the network to improve the weights (black arrow pointing backwards). This process is repeated until an optimal solution is found.", sep = " ")
fig2_cap_B <- "(B) Schematic illustrating how the MLP was used to create a new common space. Once the network was trained, the output layer was removed from the architecture. The mouse and human regional gene expression matrices were passed through the network (black arrows), resulting in matrices with columns corresponding to the hidden units in the final hidden layer of the MLP. These hidden units form the axes of the new gene expression latent space."
fig2_cap_C <- "(C) Similarity matrix displaying the gene expression latent space correlation between 67 mouse regions and 88 human regions averaged over 500 MLP training runs. Similar brains exhibit very high correlation values."
fig2_cap <- str_c("Mouse-human similarity in MLP gene expression latent space.",
                  fig2_cap_A,
                  fig2_cap_B,
                  "The training and transformation process was repeated 500 times.",
                  fig2_cap_C,
                  sep = " ")
```

```{r results2-fig2-options}
fig2_width <- 10
fig2_height <- 5.8
knitr::opts_chunk$set(include = TRUE,
                      echo = FALSE,
                      fig.width = fig2_width,
                      fig.height = fig2_height,
                      fig.cap = fig2_cap)
```

```{r results2-fig2-print}
grid.newpage()
grid.draw(fig2_grob)
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.3, 0.3, 5.75), 'inch'),
          y = unit(c(5.5, 2.85, 5.5), 'inch'),
          gp = gpar(fontsize = 14,
                    fontface = "bold"))
grid.text(c("Training the MLP classifier", "Transforming the gene expression blueprints"),
          x = unit(rep(0.5, 2), 'inch'),
          y = unit(c(5.5, 2.85), 'inch'),
          just = "left",
          gp = gpar(fontsize = 14))
grid.rect(gp = gpar(fill = NA))
```

```{r results2-fig2-clean}
rm(list = str_subset(ls(), "fig2"))
rm(arraySimLatentSpace)
```

```{r results2-fig2-options-reset, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE)
```

```{r results2-text2}
#For code chunk navigation purposes
```

To assess whether the latent space representations of the data improved the resolution of the mouse-human matches, we considered two criteria. The first was whether the similarity profiles of the mouse atlas regions were more localized within the corresponding broad regions of interest, compared with their similarity profiles in the original gene space. The second criterion was whether the degree of similarity between canonical neuroanatomical homologues improved in this new common space. The former tells us about our ability to extract finer-scale signal in these profiles, while the latter informs us about our ability to recover expected matches in this finer-scale signal. To evaluate these criteria, we computed ranked similarity profiles for every region in the mouse brain, ordered such that a rank of 1 indicates the most similar human region. In addition, given the difference in overall correlation values between the input gene space and gene expression latent space similarity matrices, we scaled the similarity profiles to the interval $\left[0, 1\right]$ in order to make comparisons between the spaces.

We evaluated the locality criterion by examining the decay rate of the head of the similarity profiles. We reasoned that the broad plateau of similarity to a coarse brain region, as seen in the anatomically-ordered similarity matrices and profiles (Figure 1, panels A and C; Figure 2, panel C), would correspond to a similar plateau at the head of the rank-ordered profiles. Moreover, the emergence of local signal would appear as an increase in the range between the peaks and troughs within the broad plateau. In the rank-ordered profiles, this would correspond to a faster rate of decay at the head of the profile. In order to quantify this decay for a given similarity profile, we computed the rank at which the profile fell to a scaled similarity value of 0.75. This was calculated for the similarity profiles of each mouse region in the initial gene space, as well as each of the 500 gene expression latent spaces. As a measurement of performance between the two representations of the data, we then took the difference in this rank between each of the latent spaces and the original gene space (Figure 3, panel A). This was done such that a negative rank difference indicated an improvement in the latent space. 

Examining the structure-wise distributions of these rank differences, we found that for the majority of regions in our mouse atlas, the MLP classification approach resulted in either an improvement in the amount of locality within a broad region, or no difference from the original gene space (Figure 3, panel B). Only a few regions performed considerably worse in the latent spaces, notably the main and accessory olfactory bulbs, as well as the cerebellar nuclei. Regions within the cortical subplate and olfactory areas (e.g. endopiriform nucleus, postpiriform transition area) gained the largest improvement from the classification approach. While the effects are smaller, the similarity profiles of regions belonging to the isocortex and cerebellar cortex also saw an improvement in locality. In contrast, regions belonging to the cerebral nuclei, the diencephalon, midbrain and hindbrain did not see much improvement in this new common space. For many such regions the degree of locality appears to be worse in this space, though only be a small number of ranks (e.g. striatum ventral region, thalamus, midbrain raphe nuclei). To evaluate how often the MLP training and transformation process returned an improvement, we computed the proportion of training runs over which the rank difference was negative or null for every mouse region (Figure 3, panel C). This elucidates the patterns seen in Figure 3, panel B, where cerebral and cerebellar regions exhibit a high proportion of runs resulting in improvement, while many subcortical regions are not improved in most training samples. Particularly, we find very low proportions for the thalamus, dentate gyrus, and striatum ventral region.

```{r results2-fig3-processing}
#' Compute scaled similarity profiles for every column in a similarity matrix
#'
#' @param similarity A similarity matrix
#' @param scale A logical value indicating whether to scale the similarity profiles
#'
#' @return A tibble containing the scaled similarity profiles
computeSimilarityProfiles <- function(similarity, scale = FALSE){
  
  profiles <- tibble()
  for(seed in colnames(similarity)){
    temp <- similarity[, seed] %>% 
      enframe(name = "Target",
              value = "Similarity") 
      
      if(scale){
        temp <- temp %>% 
          mutate(Similarity = (Similarity - min(Similarity))/(max(Similarity) - min(Similarity)))
      }
    
    temp <- temp %>% 
      mutate(TargetRank = as.numeric(factor(Target, levels = Target[order(Similarity, decreasing = TRUE)])),
             Seed = seed)
    profiles <- bind_rows(profiles, temp)
  }
  return(profiles)
}

#Include the original homologous gene similarity matrix
listSimMats <- c(list("AllGenes" = matSim_H88M67_AllGenes),
                 listSimLatentSpace)
rm(listSimLatentSpace)

#Create data frame with similarity profiles
dfSimilarityProfiles <- map_df(.x = listSimMats,
                               .f = computeSimilarityProfiles,
                               .id = "Data",
                               scale = TRUE)

#Compute the rank at s = 0.75 for all data representations
dfRankThresholds <- dfSimilarityProfiles %>% 
  filter(Similarity >= 0.75) %>% 
  group_by(Data, Seed) %>% 
  filter(Similarity == min(Similarity)) %>% 
  ungroup() %>% 
  select(Data, Seed, TargetRank) %>% 
  spread(key = "Data", value = "TargetRank")

#Compute the differences between latent space ranks and homologous gene rank
dfRankDifferences <- dfRankThresholds %>% 
  select(contains("MLP")) %>% 
  map_dfc(function(x){x - dfRankThresholds$AllGenes}) %>% 
  mutate(Seed = dfRankThresholds$Seed) %>% 
  gather(key = "Data", value = "RankDiff", -Seed) %>% 
  mutate(Seed = fct_rev(factor(Seed, levels = listLabelsMouseReordered$Region67_reordered)))

```

```{r results2-fig3-panelA-seedsim}
#Extract the chosen mouse seed
seed <- "Primary motor area"

#Some parameters
MLPsample <- "MLP_v224"
colPalette <- c("#B27700", "#00325C")
ybreaks <- seq(0, 1, 0.25)

#Data frame with MLP sample selection
dfSeedSim_Comparison <- dfSimilarityProfiles %>% 
  filter(Seed == seed,
         Data %in% c("AllGenes", MLPsample)) %>% 
  mutate(Seed = factor(Seed, levels = listLabelsMouseReordered$Region67_reordered))

#Data frame with all MLP samples
dfSeedSim_Background <- dfSimilarityProfiles %>% 
  filter(Seed == seed,
         Data != "AllGenes") %>% 
    mutate(Seed = factor(Seed, levels = listLabelsMouseReordered$Region67_reordered))

#Seed ranks at 0.75 for gene space and MLP sample
seedRanks <- c(dfRankThresholds[dfRankThresholds$Seed == seed,][["AllGenes"]],
               dfRankThresholds[dfRankThresholds$Seed == seed,][[MLPsample]])

#Rank ordered similarity plot
fig3_seedsim <- ggplot(dfSeedSim_Comparison,
                       aes(x = TargetRank,
                           y = Similarity,
                           group = Data)) +
  geom_line(data = dfSeedSim_Background,
            alpha = 0.05,
            col = "#86A6BF",
            size = 0.5) + 
  annotate(geom = "rect",
           xmin = min(seedRanks),
           xmax = max(seedRanks),
           ymin = -Inf, 
           ymax = 0.75,
           fill = "grey80",
           alpha = 0.3) + 
  annotate(geom = "segment",
           x = seedRanks,
           xend = seedRanks,
           y = -Inf,
           yend = 0.75,
           col = colPalette,
           linetype = "dashed") +
  geom_line(aes(col = Data),
            size = 1) + 
  annotate(geom = "segment",
           x = max(seedRanks),
           xend = -Inf,
           y = 0.75, 
           yend = 0.75,
           linetype = "dashed") + 
  annotate(geom = "point",
           x = seedRanks,
           y = 0.75,
           col = colPalette,
           size = 3) +
  scale_x_continuous(breaks = c(1, seq(20, 100, by = 20)),
                     limits = c(0, 89),
                     expand = c(0,0)) + 
  scale_y_continuous(limits = c(-0.05, 1.05), breaks = ybreaks) + 
  scale_colour_manual(name = "Data space",
                      labels = c("Gene expression initial space", "Gene expression latent space"),
                      values = colPalette) + 
  labs(x = "Human regions (Rank ordered)",
       y = "Scaled similarity",
       title = "Similarity profiles of the mouse primary motor area") +
  theme_bw()  +
  theme(legend.position = "bottom",
        legend.box = "horizontal",
        axis.text.x = element_text(size = 10),
        legend.title = element_blank(),
        plot.margin = margin(r = 0, b = 0, l = 0, t = 0, unit = 'inch'))

#Convert the rank ordered ggplot to a grob
fig3_seedsim_grob <- ggplotGrob(fig3_seedsim) %>% grid.force()

#Extract legend grob from ggplot
fig3_seedsim_panel_grob <- getGrob(fig3_seedsim_grob, "panel.7-5-7-5")
fig3_seedsim_ytext_grob <- getGrob(fig3_seedsim_grob, "axis-l.7-4-7-4")
fig3_seedsim_ytitle_grob <- getGrob(fig3_seedsim_grob, "ylab-l.7-3-7-3")
fig3_seedsim_xtext_grob <- getGrob(fig3_seedsim_grob, "axis-b.8-5-8-5")
fig3_seedsim_xtitle_grob <- getGrob(fig3_seedsim_grob, "xlab-b.9-5-9-5")
fig3_seedsim_legend_grob <- getGrob(fig3_seedsim_grob, "guides.3-3-3-3")
# fig3_seedsim_title_grob <- getGrob(fig3_seedsim_grob, "title.3-5-3-5")
fig3_seedsim_title_grob <- textGrob("Similarity profiles of the mouse primary motor area",
                                    x = 0, y = 0.5,
                                    just = c("left", "centre"))
```

```{r results2-fig3-panelB-distributions}
#Create data frame with summary stats for MLP samples
dfRankDifferencesSummary <- dfRankDifferences %>% 
  mutate(NonPositive = ifelse(RankDiff <= 0, TRUE, FALSE)) %>% 
  group_by(Seed) %>% 
  summarise(RankDiffMean = mean(RankDiff),
            RankDiffSd = sd(RankDiff),
            RankDiffLower = RankDiffMean - 2*RankDiffSd,
            RankDiffUpper = RankDiffMean + 2*RankDiffSd,
            PropNonPos = sum(NonPositive)/n()) %>% 
  ungroup() 

dfMouseColours <- annotation_colours_mod$MouseRegion %>% 
  enframe(name = "Region11",
          value = "Colour") %>% 
  inner_join(dfLabelsMouse %>% 
               select(Region11, Region67) %>% 
               distinct(),
             by = "Region11") %>% 
  mutate(Region67 = fct_rev(factor(Region67, levels = listLabelsMouseReordered$Region67_reordered)),
         Region11 = factor(Region11, levels = listLabelsMouseReordered$Region11_reordered))

dfRankDifferencesSummary <- inner_join(dfRankDifferencesSummary,
                                       dfMouseColours,
                                       by = c("Seed" = "Region67"))

#Parameters
ybreaks <- seq(-50, 50, by = 25)

#Rank differences distribution plot
fig3_distributions <- ggplot(dfRankDifferencesSummary, aes(x = Seed, y = RankDiffMean, col = Region11)) + 
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_pointrange(aes(ymin = RankDiffLower,
                      ymax = RankDiffUpper),
                  size = 0.25) + 
  coord_flip() + 
  scale_x_discrete(position = "top") + 
  scale_y_continuous(breaks = ybreaks) + 
  scale_colour_manual(values = annotation_colours_mod$MouseRegion) + 
  labs(x = "Mouse region",
       y = "Rank difference",
       title = "Difference in rank at s = 0.75 between gene space and latent spaces") + 
  theme_bw() + 
  theme(axis.text.y = element_text(size = 6,
                                   colour = dfRankDifferencesSummary$Colour,
                                   face = "bold"),
        legend.position = "none",
        plot.margin = margin(r = 0, b = 0, l = 0, t = 0, unit = 'inch'))
fig3_distributions_grob <- ggplotGrob(fig3_distributions) %>% grid.force()

fig3_distributions_panel_grob <- getGrob(fig3_distributions_grob, "panel.7-5-7-5")
fig3_distributions_ytext_grob <- getGrob(fig3_distributions_grob, "axis-r.7-6-7-6")
fig3_distributions_ytitle_grob <- getGrob(fig3_distributions_grob, "ylab-r.7-7-7-7")
fig3_distributions_xtext_grob <- getGrob(fig3_distributions_grob, "axis-b.8-5-8-5")
fig3_distributions_xtitle_grob <- getGrob(fig3_distributions_grob, "xlab-b.9-5-9-5")
fig3_distributions_title_grob <- textGrob("Difference in rank at s = 0.75 between gene\nspace and latent spaces",
                                          x = 0.05, y = 0.5,
                                          just = c("left", "centre"),
                                          gp = gpar(lineheight = 0.8))
```

```{r results2-fig3-panelC-proportions}
#Create MINC array for proportions non-positive
fig3_ss_array <- mincBuildArray(values = dfRankDifferencesSummary$PropNonPos,
                                values.names = dfRankDifferencesSummary$Seed,
                                labels = atlasMouse_67,
                                defs = dfAtlasMouse_67)

#Generate base slice series
fig3_ss_grob <- sliceSeries(nrow = 3, ncol = 4, begin = 70, end = 330) %>% 
  anatomy(mincArray(dsurqeAnat), low = 700, high = 1400) %>% 
  overlay(mincArray(fig3_ss_array), low = 0, high = 1) %>% 
  grobify()

#Create slice series legend
fig3_ss_legend_palette <- MRIcrotome:::defaultCol()
fig3_ss_legend_palette <- fig3_ss_legend_palette[length(fig3_ss_legend_palette):1]
fig3_ss_legend_scale_width <- 0.3
fig3_ss_legend_scale_height <- 1
fig3_ss_legend_scale_x <- 0.95
fig3_ss_legend_scale_y <- 0.5
fig3_ss_legend_scale_grob <- rasterGrob(fig3_ss_legend_palette,
                                        x = fig3_ss_legend_scale_x,
                                        y = fig3_ss_legend_scale_y,
                                        width = fig3_ss_legend_scale_width,
                                        height = fig3_ss_legend_scale_height,
                                        just = c("right", "centre"))

#Create slice series legend text
fig3_ss_legend_text <- c(min(fig3_ss_array), max(fig3_ss_array))
fig3_ss_legend_text_x <- fig3_ss_legend_scale_x - fig3_ss_legend_scale_width - 0.1
fig3_ss_legend_text_y <- fig3_ss_legend_scale_y + 0.5*c(-1*fig3_ss_legend_scale_height,
                                                        fig3_ss_legend_scale_height)
fig3_ss_legend_text_grob <- textGrob(fig3_ss_legend_text,
                                     x = fig3_ss_legend_text_x,
                                     y = fig3_ss_legend_text_y)

#Create slice series legend title
fig3_ss_legend_title_x <- 0.4
fig3_ss_legend_title_y <- fig3_ss_legend_scale_y
fig3_ss_legend_title_grob <- textGrob("Proportion of non-positive\nrank differences",
                                      x = fig3_ss_legend_title_x,
                                      y = fig3_ss_legend_title_y,
                                      rot = 90,
                                      gp = gpar(fontsize = 12,
                                                lineheight = 0.8))

#Combine slice series legend grobs
fig3_ss_legend_grob <- gTree(children = gList(fig3_ss_legend_scale_grob,
                                              fig3_ss_legend_text_grob,
                                              fig3_ss_legend_title_grob))
```

```{r results2-fig3-grob}
#Generate the figure grob
fig3_grob <- arrangeGrob(fig3_seedsim_panel_grob, #1
                         fig3_seedsim_ytext_grob, #2
                         fig3_seedsim_ytitle_grob, #3
                         fig3_seedsim_xtext_grob, #4
                         fig3_seedsim_xtitle_grob, #5
                         fig3_seedsim_legend_grob, #6
                         fig3_seedsim_title_grob, #7
                         fig3_ss_grob, #8
                         fig3_ss_legend_grob, #9
                         fig3_distributions_panel_grob,#10
                         fig3_distributions_ytext_grob, #11
                         fig3_distributions_ytitle_grob, #12
                         fig3_distributions_xtext_grob, #13
                         fig3_distributions_xtitle_grob, #14
                         fig3_distributions_title_grob, #15
                         layout_matrix = rbind(c(NA, NA,  7, NA, 15, 15, 15),
                                               c( 3,  2,  1, NA, 10, 11, 12),
                                               c(NA, NA,  4, NA, 10, 11, 12),
                                               c(NA, NA,  5, NA, 10, 11, 12),
                                               c(NA, NA,  6, NA, 10, 11, 12),
                                               c( 9,  9,  8, NA, 10, 11, 12),
                                               c(NA, NA, NA, NA, 13, NA, NA),
                                               c(NA, NA, NA, NA, 14, NA, NA)),
                         widths = unit(c(0.5, 0.4, 4.8, 0.25, 2.2, 1.2, 0.5), 'inch'),
                         heights = unit(c(0.5, 2, 0.25, 0.25, 0.4, 2.7, 0.2, 0.3), 'inch'))
```

```{r results2-fig3-interactive, include=FALSE, echo=FALSE, fig.width=10, fig.height=6.7}
grid.newpage()
grid.draw(fig3_grob)
sliceAMBAWidth <- 0.9
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(9.5, 'inch'),
              y = unit(0.9, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.23, 5.90, 0.23), 'inch'),
          y = unit(c(6.35, 6.35, 3.15), 'inch'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results2-fig3-caption}
fig3_cap_A <- "(A) The amount of local signal within a broadly similar region of the brain for a finer seed region's (e.g. primary motor area) similarity profile can be quantified by the decay rate of the head of the rank-ordered profile. Decay rate was quantified by computing the rank at a similarity of 0.75. This metric was compared between the initial gene expression space (orange line) and every gene expression latent space resulting from repeated training of the MLP (every blue line is a training outcome, heavy blue line serves as an example). A negative difference between these rank metrics indicates an improvement in locality in the latent space."
fig3_cap_B <- "(B) Structure-wise distributions of differences in rank at a similarity of 0.75 between the initial gene expression space and the gene expression latent spaces. Points and error bars represent mean and 95% confidence interval. Dashed black line at 0 indicates the threshold for improvement in one space over the other. Colours correspond to AMBA annotations as in Figures 1 and 2."
fig3_cap_C <- "(C) Proportion of MLP training runs resulting in an improvement or null difference in the gene expression latent space compared with the initial space. Cortical and cerebellar regions exhibit high proportions of improvement, while subcortical regions are less likely to be improved by the classification process."
fig3_cap <- str_c("Quantifying improvement in locality in gene expression latent space.",
                  fig3_cap_A,
                  fig3_cap_B,
                  fig3_cap_C,
                  sep = " ")
```

```{r results2-fig3-options}
fig3_width <- 10
fig3_height <- 6.7
knitr::opts_chunk$set(include = TRUE,
                      echo = FALSE,
                      fig.width = fig3_width,
                      fig.height = fig3_height,
                      fig.cap = fig3_cap)
```

```{r results2-fig3-print}
grid.newpage()
grid.draw(fig3_grob)
sliceAMBAWidth <- 0.9
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(9.5, 'inch'),
              y = unit(0.9, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B.", "C."),
          x = unit(c(0.23, 5.90, 0.23), 'inch'),
          y = unit(c(6.35, 6.35, 3.15), 'inch'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results2-fig3-clean}
rm(list = str_subset(ls(), "fig3"))
```

```{r results2-fig3-options-reset, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE)
```

```{r results2-fig4-processing}
#Import the data frame containing mouse-human canonical pairs
dfCanonicalPairs_H88M67 <- suppressMessages(read_csv("../../../data/MouseHumanMatches_H88M67.csv"))

#Extract the ranks for canonical pairs in all data sets
dfCanonicalPairs_H88M67_Ranks <- dfSimilarityProfiles %>% 
  inner_join(dfCanonicalPairs_H88M67,
             by = c("Seed" = "Mouse")) %>% 
  filter(Target == Human) %>% 
  mutate(Seed = fct_rev(factor(Seed, levels = listLabelsMouseReordered$Region67_reordered))) %>% 
  select(Data, Seed, Target, Similarity, TargetRank)

#Convert data frame to wide format to compute rank differences
dfCanonicalPairs_H88M67_RankDiffs <- dfCanonicalPairs_H88M67_Ranks %>% 
  select(Data, Seed, TargetRank) %>% 
  spread(key = "Data", value = "TargetRank")

#Compute rank differences and convert back to long format
dfCanonicalPairs_H88M67_RankDiffs <- dfCanonicalPairs_H88M67_RankDiffs %>% 
  select(contains("MLP")) %>% 
  map_dfc(function(x){x - dfCanonicalPairs_H88M67_RankDiffs$AllGenes}) %>% 
  mutate(Seed = dfCanonicalPairs_H88M67_RankDiffs$Seed) %>% 
  gather(key = "Data", value = "RankDiff", -Seed) %>% 
  mutate(Seed = fct_rev(factor(Seed, levels = listLabelsMouseReordered$Region67_reordered)))
```

```{r results2-text3}
#For code chunk navigation purposes
```

The decay rates of the similarity profiles indicated that the MLP classifier approach improved our ability to identify finer scale matches for a number of brain regions. However, this does not mean that those improved matches are biologically meaningful. Our second criterion for evaluating the performance of the MLP addresses whether this improvement in locality captures what we would expect in terms of known mouse-human homologies. To this end, we examined the degree of similarity between canonical mouse-human matches, both in the initial gene expression space and in the set of latent spaces. We began by establishing a list of `r nrow(dfCanonicalPairs_H88M67)` canonical mouse-human homolous pairs. For each of these regions in the mouse brain, we examined how the rank of the canonical human match changed in the rank-ordered similarity profiles between the latent spaces and the original gene space (Figure 4, panel A). The lower the rank, the more similar the canonical pair, with a rank of 1 indicating maximal similarity. We additionally computed the difference between the rank of the expected human match in the latent space and in the original common space. This was done for each of the 500 latent spaces. For each region in the mouse brain with a canonical human homologue, we used these differences to compute the proportion of latent spaces that returned an improvement or null difference when compared with the original gene space (Figure 4, panel B). We find that for most regions in the mouse brain, the MLP classification approach either improves the seed region's similarity to its expected match or performs as well as the comparison using all homologous genes. The improvement is most pronounced for regions in the cortical subplate and isocortex, particularly the frontal pole and visual areas. The gene expression latent spaces do not provide an improvement for many regions in the sub-cortex, since the initial common space was already recapitulating the appropriate homologues with maximal similarity. In such cases, the classification approach performs as well as the original approach. While many regions in the cerebellum feature some improvement in the latent spaces, the variation in the rank of the human homologue is often quite large, indicating some instability in the neural network's ability to recover these matches. By examining the identity of the top ranked human match for a given cerebellar seed region (e.g. declive (VI)) across different latent space samples, we find that the top match is always a cerebellar region (Figure 4, panel C). This suggests that the variability observed in the cerebellar regions corresponds to a shuffling in the positions of the cerebellar targets on the human side. The same is true for hippocampal regions. While the canonical human match is not always the top match, the highest ranked region always belongs to the hippocampal formation.

```{r results2-fig4-panelA-distributions}
dfCanonicalPairs_H88M67_Ranks <- dfCanonicalPairs_H88M67_Ranks %>% 
  mutate(Data2 = ifelse(Data == "AllGenes", "AllGenes", "MLP"),
         Data2 = factor(Data2, levels = c("MLP", "AllGenes")))

dfCanonicalPairs_H88M67_Ranks_AllGenes <- dfCanonicalPairs_H88M67_Ranks %>% 
  filter(Data == "AllGenes")

dfCanonicalPairs_H88M67_Ranks_MLP <- dfCanonicalPairs_H88M67_Ranks %>% 
  filter(Data != "AllGenes") %>% 
  group_by(Seed) %>% 
  summarise(RankMean = mean(TargetRank),
            RankSdLower = RankMean - 2*sd(TargetRank),
            RankSdUpper = RankMean + 2*sd(TargetRank)) %>% 
  ungroup()

dfMouseColours <- annotation_colours_mod$MouseRegion %>% 
  enframe(name = "Region11",
          value = "Colour") %>% 
  inner_join(dfLabelsMouse %>% 
               select(Region11, Region67) %>% 
               distinct(),
             by = "Region11") %>% 
  semi_join(dfCanonicalPairs_H88M67,
            by = c("Region67" = "Mouse")) %>% 
  mutate(Region67 = fct_rev(factor(Region67, levels = listLabelsMouseReordered$Region67_reordered))) %>% 
  arrange(Region67)

#Create rank distributions plot
fig4_distributions <- ggplot(dfCanonicalPairs_H88M67_Ranks_MLP,
       aes(x = Seed)) + 
  geom_pointrange(mapping = aes(y = RankMean,
                                ymin = RankSdLower,
                                ymax = RankSdUpper),
                  # col = "grey70",
                  col = "#719DC0",
                  size = 0.25) + 
  geom_point(data = dfCanonicalPairs_H88M67_Ranks_AllGenes, 
             mapping = aes(y = TargetRank),
             # col = "black",
             col = "#B27700",
             size = 1.5) +  
  coord_flip(ylim = c(0,35)) + 
  scale_y_continuous(breaks = c(1, seq(10, 40, by = 10)),
                     limits = c(0, 35),
                     expand = c(0,0)) + 
  labs(x = "Mouse region",
       y = "Rank") + 
  theme_bw() +
  theme(axis.text.y = element_text(colour = dfMouseColours$Colour,
                                   face = "bold"),
        plot.margin = margin(t = 0, r = 0, l = 0, b = 0, unit = 'inch'))
fig4_distributions_grob <- ggplotGrob(fig4_distributions) %>% grid.force()

fig4_distributions_panel_grob <- getGrob(fig4_distributions_grob, "panel.7-5-7-5")
fig4_distributions_ytext_grob <- getGrob(fig4_distributions_grob, "axis-l.7-4-7-4")
fig4_distributions_ytitle_grob <- getGrob(fig4_distributions_grob, "ylab-l.7-3-7-3")
fig4_distributions_xtext_grob <- getGrob(fig4_distributions_grob, "axis-b.8-5-8-5")
fig4_distributions_xtitle_grob <- getGrob(fig4_distributions_grob, "xlab-b.9-5-9-5")

#Create a separate plot to make the legend
fig4_distributions_legend <- ggplot(dfCanonicalPairs_H88M67_Ranks, 
                                    aes(x = TargetRank, y = Seed, col = Data2)) + 
  geom_point() + 
  scale_colour_manual(name = "Data",
                      # values = c("grey70", "black"),
                      values = c("#719DC0", "#B27700"),
                      labels = c("Gene expression latent space", "Gene expression initial space")) + 
  theme_bw() + 
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.title = element_blank())

#Extract the legend grob from the plot
fig4_distributions_legend_grob <- ggplotGrob(fig4_distributions_legend) %>% 
  grid.force() %>% 
  getGrob("guides.3-3-3-3")

#Create plot title
fig4_distributions_title_grob <- textGrob("Rank of canonical human homologue",
                                          x = unit(1, 'npc'), 
                                          y = unit(0.3, 'npc'),
                                          just = c("right", "bottom"))
```

```{r results2-fig4-panelB-proportions}
#Compute the proportion of rank differences non-positive
dfCanonicalPairs_H88M67_RankDiffsProp <- dfCanonicalPairs_H88M67_RankDiffs %>% 
  mutate(NonPositive = ifelse(RankDiff <= 0, TRUE, FALSE)) %>% 
  group_by(Seed) %>% 
  summarise(PropNonPos = sum(NonPositive)/n()) %>% 
  ungroup()

#Create MINC array for proportions non-positive
fig4_ss_array <- mincBuildArray(values = dfCanonicalPairs_H88M67_RankDiffsProp$PropNonPos,
                                values.names = dfCanonicalPairs_H88M67_RankDiffsProp$Seed,
                                labels = atlasMouse_67,
                                defs = dfAtlasMouse_67)

#Generate base slice series
fig4_ss_grob <- sliceSeries(nrow = 8, ncol = 2, begin = 70, end = 330) %>% 
  anatomy(mincArray(dsurqeAnat), low = 700, high = 1400) %>% 
  overlay(mincArray(fig4_ss_array), low = 0, high = 1) %>% 
  legend("Proportion of non-positive rank differences") %>% 
  grobify()
```

```{r}
treeHuman_88 <- Clone(treeHuman)
pruneAnatTree(treeHuman_88,
              nodes = listLabelsHumanReordered$Region88_reordered,
              method = "BelowNode")

dfCanonicalPairs_H88M67_TopMatch <- dfSimilarityProfiles %>% 
  inner_join(dfCanonicalPairs_H88M67,
             by = c("Seed" = "Mouse")) %>% 
  filter(Data != "AllGenes",
         TargetRank == 1) %>% 
  select(Data, Seed, HumanPair = Human, Target)

dfCanonicalPairs_H88M67_TopMatch_Summary <- dfCanonicalPairs_H88M67_TopMatch %>% 
  group_by(Seed, Target) %>% 
  summarise(Count = n(),
            Prop = Count/500) %>% 
  ungroup()

# seed <- "Declive (VI)"
seed <- "Field CA2"

dfCanonicalPairs_H88M67_TopMatch_Summary_Seed <- dfCanonicalPairs_H88M67_TopMatch_Summary %>% 
  filter(Seed == seed)

treeHuman_88_seedprop <- Clone(treeHuman_88)
treeHuman_88_seedprop$Do(function(node){
  if(isLeaf(node)){
    ind <- dfCanonicalPairs_H88M67_TopMatch_Summary_Seed$Target == node$name
    if(sum(ind) == 1){
      node$prop <- dfCanonicalPairs_H88M67_TopMatch_Summary_Seed[ind,][["Prop"]]
    } else if (sum(ind) == 0){
      node$prop <- 0
    } else {
      print(node$name)
    }
  }
})

```

```{r results2-fig4-plot-treedist, eval=FALSE}
# treeHuman_88 <- Clone(treeHuman)
# pruneAnatTree(treeHuman_88,
#               nodes = listLabelsHumanReordered$Region88_reordered,
#               method = "BelowNode")
# 
# structsHuman <- treeHuman_88$Get("name", filterFun = isLeaf)
# 
# dfTreeDist <- expand.grid(Node1 = structsHuman,
#                           Node2 = structsHuman,
#                           stringsAsFactors = FALSE) %>% 
#   mutate(TreeDist = 0)
# 
# for(i in 1:nrow(dfTreeDist)){
#   node1 <- dfTreeDist[i,][["Node1"]]
#   node2 <- dfTreeDist[i,][["Node2"]]
#   dfTreeDist[i,][["TreeDist"]] <- Distance(FindNode(treeHuman_88, node1),
#                                            FindNode(treeHuman_88, node2))
# }
# 
# dfCanonicalPairs_H88M67_TopMatch_TreeDist <- dfSimilarityProfiles %>%
#   inner_join(dfCanonicalPairs_H88M67,
#              by = c("Seed" = "Mouse")) %>% 
#   filter(Data != "AllGenes", 
#          TargetRank == 1) %>% 
#   select(Data, Seed, HumanPair = Human, Target) %>% 
#   inner_join(dfTreeDist,
#              by = c("HumanPair" = "Node1",
#                     "Target" = "Node2"))
# 
# dfCanonicalPairs_H88M67_TopMatch_TreeDist_Summary <- dfCanonicalPairs_H88M67_TopMatch_TreeDist %>%
#   group_by(Seed, TreeDist) %>% 
#   summarise(Count = n(),
#             Prop = Count/500) %>% 
#   ungroup()
# 
# dfCanonicalPairs_H88M67_TopMatch_TreeDist_Plot <- expand.grid(Seed = unique(dfCanonicalPairs_H88M67_TopMatch_TreeDist_Summary$Seed),
#                       TreeDist = unique(dfCanonicalPairs_H88M67_TopMatch_TreeDist_Summary$TreeDist),
#                       stringsAsFactors = FALSE) %>% 
#   mutate(PropTemp = 0) %>% 
#   left_join(dfCanonicalPairs_H88M67_TopMatch_TreeDist_Summary,
#             by = c("Seed", "TreeDist")) %>% 
#   mutate(Prop = ifelse(is.na(Prop), PropTemp, Prop),
#          Count = ifelse(is.na(Count), PropTemp, Count),
#          Seed = fct_rev(factor(Seed, levels = listLabelsMouseReordered$Region67_reordered)),
#          TreeDist = factor(TreeDist))
# 
# fig4_treedist <- ggplot(dfCanonicalPairs_H88M67_TopMatch_TreeDist_Plot,
#        aes(x = Seed, y = TreeDist, fill = Prop)) + 
#   geom_raster() + 
#   coord_flip() + 
#   scale_fill_gradientn(colours = colorRampPalette(c("white", "black"))(255)) + 
#   theme_bw() + 
#   theme(axis.ticks = element_blank(),
#         axis.text.y = element_blank(),
#         axis.title.y = element_blank(),
#         legend.position = "bottom",
#         legend.direction = "horizontal",
#         legend.title = element_blank(),
#         plot.margin = margin(l = 0, b = 0, r = 0, t = 0, unit = 'inch'))
# fig4_treedist_grob <- ggplotGrob(fig4_treedist) %>% grid.force()
# 
# fig4_treedist_panel_grob <- getGrob(fig4_treedist_grob, "panel.7-5-7-5")
# fig4_treedist_xtext_grob <- getGrob(fig4_treedist_grob, "axis-b.8-5-8-5")
# fig4_treedist_xtitle_grob <- getGrob(fig4_treedist_grob, "xlab-b.9-5-9-5")
# fig4_treedist_legend_grob <- getGrob(fig4_treedist_grob, "guides.3-3-3-3")
```

```{r results2-fig4-grob}
#Generate figure 4 grob
#Old grob with tree distance proportions
# fig4_grob <- arrangeGrob(fig4_distributions_panel_grob, #1
#                          fig4_distributions_ytext_grob,#2
#                          fig4_distributions_ytitle_grob,#3
#                          fig4_distributions_xtext_grob,#4
#                          fig4_distributions_xtitle_grob,#5
#                          fig4_distributions_legend_grob, #6
#                          fig4_distributions_title_grob, #7
#                          fig4_treedist_panel_grob, #8
#                          fig4_treedist_xtext_grob, #9
#                          fig4_treedist_xtitle_grob, #10
#                          fig4_treedist_legend_grob, #11
#                          fig4_ss_grob, #12
#                          fig4_ss_title_grob, #13
#                          layout_matrix = rbind(c(NA, NA, 7, NA, NA, NA, 13),
#                                                c( 3,  2, 1, NA,  8, NA, 12),
#                                                c(NA, NA, 4, NA,  9, NA, NA),
#                                                c(NA, NA, 5, NA, 10, NA, NA),
#                                                c(NA, NA, 6, NA, NA, NA, NA),
#                                                c(NA, NA, 6, NA, 11, NA, NA)),
#                          widths = unit(c(0.60, 2.0, 2.2, 0.25, 2.2, 0.25, 2.5), 'inch'),
#                          heights = unit(c(0.5, 4.55, 0.175, 0.175, 0.1, 0.7), 'inch'))

#New grob for tree plot
fig4_grob <- arrangeGrob(fig4_distributions_panel_grob, #1
                         fig4_distributions_ytext_grob,#2
                         fig4_distributions_ytitle_grob,#3
                         fig4_distributions_xtext_grob,#4
                         fig4_distributions_xtitle_grob,#5
                         fig4_distributions_legend_grob, #6
                         fig4_distributions_title_grob, #7
                         fig4_ss_grob, #8
                         textGrob("Panel C\nTree proportions plot\nTree diagrams for two seeds\n(e.g. Declive and CA2)\nEdges and nodes coloured\nwith Allen colours\nSize of nodes = proportion\nof times that node is the\ntop match for the given seed\nacross latent spaces."), #10
                         layout_matrix = rbind(c(NA, NA, 7, NA, NA, NA, NA),
                                               c( 3,  2, 1, NA,  8, NA, 10),
                                               c(NA, NA, 4, NA, NA, NA, NA),
                                               c(NA, NA, 5, NA, NA, NA, NA),
                                               c(NA, NA, 6, NA, NA, NA, NA),
                                               c(NA, NA, 6, NA, NA, NA, NA)),
                         widths = unit(c(0.60, 2.0, 2.2, 0.25, 2.5, 0.25, 2.2), 'inch'),
                         heights = unit(c(0.4, 4.55, 0.175, 0.175, 0.1, 0.6), 'inch'))
```

```{r results2-fig4-interactive, include=FALSE, echo=FALSE, fig.width=10, fig.height=6.2}
grid.newpage()
grid.draw(fig4_grob)
sliceAMBAWidth <- 0.9
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(2.1, 'inch'),
              y = unit(0.55, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B."),
          x = unit(c(0.2, 4.975), 'inch'),
          y = unit(c(0.95, 0.95), 'npc'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results2-fig4-caption}
fig4_cap_A <- "(A) Comparing the ranks of canonical human matches for mouse seed regions between the initial gene expression space and gene expression latent spaces. Points and error bars represent mean and 95% confidence interval. Axis colours correspond to AMBA annotations."
fig4_cap_B <- "(B) Proportion of latent spaces resulting in an improvement or null difference compared with the initial gene space. Uncoloured areas correspond to regions with no establish canonical human match."
fig4_cap_C <- "(C) Proportion of latent spaces returning each tree node as the top match for the given seed."
fig4_cap <- str_c("Recovering canonical homologues in gene expression space.",
                  fig4_cap_A,
                  fig4_cap_B,
                  fig4_cap_C,
                  sep = " ")
```

```{r results2-fig4-options}
fig4_width <- 10
fig4_height <- 6.2
knitr::opts_chunk$set(include = TRUE,
                      echo = FALSE,
                      fig.width = fig4_width,
                      fig.height = fig4_height,
                      fig.cap = fig4_cap)
```

```{r results2-fig4-print}
grid.newpage()
grid.draw(fig4_grob)
sliceAMBAWidth <- 0.9
sliceAMBAHeight <- sliceAMBAWidth/asp
vp = viewport(x = unit(2.1, 'inch'),
              y = unit(0.55, 'inch'),
              width = unit(sliceAMBAWidth, 'inch'),
              height = unit(sliceAMBAHeight, 'inch'))
pushViewport(vp)
grid.draw(sliceAMBALegend_panel_grob)
popViewport()
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B."),
          x = unit(c(0.2, 4.975), 'inch'),
          y = unit(c(0.95, 0.95), 'npc'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results2-fig4-clean}
rm(list = str_subset(ls(), "fig4"))
```

```{r results2-fig4-options-reset, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE)
```

```{r results2-text4}
#For code chunk navigation purposes
```

These results demonstrate that the MLP classification approach improves our ability to resolve finer scale mouse-human neuroanatomical matches within the broadly similar regions obtained using the initial gene expression space. By training a classifier to predict the atlas labels in one species, we were able to generate a new common space that amplified the amount of local signal within broadly similar regions while also improving our ability to recover known neuroanatomical homologues. 


## Sensorimotor areas of the mouse isocortex are more strongly conserved than association areas {#results-3}

```{r results3-text1}
#For code chunk navigation purposes
```

Having validated our ability to resolve finer scale matches using the gene expression latent space, we proceeded to investigate hypotheses about conservation of brain areas between the mouse and human. We hypothesized that sensorimotor areas of the cortex would be more conserved than association areas \edit{Need some literature justification and contextualization here}. We quantified the degree of conservation for a given cortical seed region in one species as the maximal correlation value across all target regions in the other species. We evaluated this quantity for every region in the mouse isocortex in each of the 500 gene expression latent spaces (Figure 5, panel A). We further probed the association between cortex type and conservation by computing the average maximal correlation per cortex type in each of the gene expression latent spaces (Figure 5, panel B). On average, we find that mouse sensorimotor cortical areas exhibit a greater degree of conservation than association areas, with the primary motor and somatosensory areas being the most conserved. Despite the stochasticity that emerges due to the training process of the MLP classifier, mouse sensorimotor cortical areas consistently exhibit larger maximal correlation values than association areas. 



```{r results3-fig5-processing}
#Extract MLP latent spaces
indMLP <- str_detect(names(listSimMats), "MLP")
listSimMats <- listSimMats[indMLP]

#Compute similarity profiles in MLP latent spaces
dfSimilarityProfiles <- map_df(.x = listSimMats,
                               .f = computeSimilarityProfiles,
                               .id = "Data")

#Extracts mouse regions in isocortex
treeMouse_Cx <- FindNode(treeMouse_67, "Isocortex")
structsMouse_Cx <- treeMouse_Cx$Get("name", filterFun = isLeaf)

#Filter similarity profiles for isocortical regions
dfSimilarityProfiles_Cx <- dfSimilarityProfiles %>% 
  filter(Seed %in% structsMouse_Cx)

#Define sensory isocortical regions
structsMouse_Cx_sensory <- c("Primary auditory area",
                             "Dorsal auditory area",
                             "Ventral auditory area",
                             "Primary motor area",
                             "Secondary motor area",
                             "Primary somatosensory area",
                             "Supplemental somatosensory area",
                             "Visual areas")

#Define association isocortical regions
structsMouse_Cx_association <- structsMouse_Cx[!(structsMouse_Cx %in% structsMouse_Cx_sensory)]
```

```{r results3-fig5-panelA-regional}
#Identify maximal similarity values for every seed and data set
dfSimilarityProfiles_Cx_MaxSim <- dfSimilarityProfiles_Cx %>%
  group_by(Data, Seed) %>% 
  filter(Similarity == max(Similarity)) %>% 
  ungroup()

#Compute maximal similarity summary statistics for each isocortical region
dfSimilarityProfiles_Cx_MaxSim_Summary <- dfSimilarityProfiles_Cx_MaxSim %>% 
  group_by(Seed) %>% 
  summarise(SimilarityMean = mean(Similarity),
            SimilaritySdLower = SimilarityMean - 2*sd(Similarity),
            SimilaritySdUpper = SimilarityMean + 2*sd(Similarity)) %>% 
  ungroup() %>% 
  mutate(Seed = factor(Seed, levels = Seed[order(SimilarityMean)]),
         CortexType = ifelse(Seed %in% structsMouse_Cx_sensory, "Sensorimotor", "Association"))

fig5_regionaldist <- ggplot(dfSimilarityProfiles_Cx_MaxSim_Summary, 
       aes(x = Seed, 
           y = SimilarityMean,
           ymin = SimilaritySdLower,
           ymax = SimilaritySdUpper,
           col = CortexType)) + 
  geom_pointrange() + 
  coord_flip() +
  scale_colour_manual(values = c("#B27700", "#00325C")) +
  labs(x = "Mouse isocortical regions",
       y = "Maximal correlation",
       col = "Type of cortex") + 
  theme_bw() + 
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        legend.direction = "horizontal",
        plot.margin = margin(l = 0, r = 0, b = 0, t = 0, unit = 'inch'))
fig5_regionaldist_grob <- ggplotGrob(fig5_regionaldist) %>% grid.force()

#Extract legend from plot
fig5_regionaldist_legend_grob <- getGrob(fig5_regionaldist_grob, "guides.3-3-3-3")
fig5_regionaldist <- fig5_regionaldist + 
  theme(legend.position = "none")
fig5_regionaldist_grob <- ggplotGrob(fig5_regionaldist) %>% grid.force()
```

```{r results3-fig5-panelB-cortextype}
#Compute mean maximal similarity per cortex type and data set
dfSimilarityProfiles_Cx_MaxSim_Compare <- dfSimilarityProfiles_Cx_MaxSim %>% 
  mutate(CortexType = ifelse(Seed %in% structsMouse_Cx_sensory, "Sensorimotor", "Association")) %>% 
  group_by(Data, CortexType) %>% 
  summarise(SimilarityMean = mean(Similarity)) %>%
  ungroup()

#Set seed for jittering
set.seed(123)

#Plot
fig5_cortexdist <- ggplot(dfSimilarityProfiles_Cx_MaxSim_Compare,
       aes(x = CortexType, y = SimilarityMean)) + 
  geom_jitter(width = 0.2,
              col = "grey80",
              size = 1) + 
  geom_boxplot(outlier.shape = NA,
               alpha = 0.3) + 
  labs(x = "Type of cortex",
       y = "Average maximal correlation") + 
  theme_bw() + 
  theme(plot.margin = margin(l = 0, r = 0, b = 0, t = 0, unit = 'inch'))
fig5_cortexdist_grob <- ggplotGrob(fig5_cortexdist) %>% grid.force()
```

```{r results3-fig5-grob}
#Figure 5 title grob
fig5_title <- textGrob("Conservation of mouse cortical sensorimotor and association areas",
                       x =  0.65)

#Generate figure 5 grob
# fig5_grob <- arrangeGrob(fig5_regionaldist_grob, #1
#                          fig5_regionaldist_legend_grob, #2
#                          fig5_regionaldist_title_grob, #3
#                          fig5_cortexdist_grob, #4
#                          fig5_cortexdist_title_grob, #5
#                          layout_matrix = rbind(c(NA,  3, 3, NA,  5, NA),
#                                                c(NA,  1, 1, NA,  4, NA),
#                                                c(NA, NA, 2, NA, NA, NA)),
#                          widths = unit(c(0.2, 2.238, 2.238, 0.25, 2.875, 0.2), 'inch'),
#                          heights = unit(c(0.25, 4.2, 0.25), 'inch'))
fig5_grob <- arrangeGrob(fig5_regionaldist_grob, #1
                         fig5_regionaldist_legend_grob, #2
                         fig5_cortexdist_grob, #3
                         fig5_title, #4
                         layout_matrix = rbind(c(NA,  4,  4,  4,  4, NA),
                                               c(NA,  1,  1, NA,  3, NA),
                                               c(NA, NA,  2, NA, NA, NA),
                                               c(NA, NA, NA, NA, NA, NA)),
                         widths = unit(c(0.2, 2.238, 2.238, 0.25, 2.875, 0.2), 'inch'),
                         heights = unit(c(0.4, 4.2, 0.25, 0.2), 'inch'))
```

```{r results3-fig5-interactive, include=FALSE, echo=FALSE, fig.width=8, fig.height=5.2}
grid.newpage()
grid.draw(fig5_grob)
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B."),
          x = unit(c(0.29, 5.02), 'inch'),
          y = unit(rep(0.88, 2), 'npc'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results3-fig5-caption}
fig5_cap_A <- "(A) Conservation was evaluated using the maximal correlation value of seed region. Points and error bars represent mean and 95% confidence interval over latent space samples. Sensorimotor areas tend to have higher maximal correlation values on average."
fig5_cap_B <- "(B) Average maximal similarity per cortex type in each gene expression latent space."
fig5_cap <- str_c("Conservation of mouse cortical areas. The gene expression latent space can be used to evaluate evolutionary hypotheses such as whether sensorimotor or association cortical areas are more conserved between the mouse and human.",
                  fig5_cap_A,
                  fig5_cap_B,
                  sep = " ")
```

```{r results3-fig5-options}
fig5_width <- 8
fig5_height <- 5.2
knitr::opts_chunk$set(include = TRUE,
                      echo = FALSE,
                      fig.width = fig5_width,
                      fig.height = fig5_height,
                      fig.cap = fig5_cap)
```

```{r results3-fig5-print}
grid.newpage()
grid.draw(fig5_grob)
grid.rect(gp = gpar(fill = NA))
grid.text(c("A.", "B."),
          x = unit(c(0.29, 5.02), 'inch'),
          y = unit(rep(0.88, 2), 'npc'),
          gp = gpar(fontsize = 14, fontface = "bold"))
```

```{r results3-fig5-clean}
rm(list = str_subset(ls(), "fig5"))
```

```{r results3-fig5-options-reset, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      include = FALSE)
```


# Discussion {#discussion}

\edit{To be filled in. Need some sense about how to contextualize these results before I can write this.}

# Materials and methods {#materials-methods}

## Mouse gene expression data

For the mouse expression data, we used the whole brain in-situ hybridization (ISH) coronal data set from the Allen Mouse Brain Atlas [@Lein2007]. \edit{Sentence or two about how ISH MINC files were generated from the raw AMBA data}. The ISH images for 4346 genes were imported and masked to form a gene-by-voxel expression matrix. We pre-processed this data by first applying a `log2` transformation for consistency with the human data set. Subsequently we filtered out genes for which more than 20% of voxels contained missing values. For those genes with replicated ISH experiments, we averaged expression of each voxel across the experiments. Finally we applied a K-nearest neighbours algorithm to impute the remaining missing values. This was done using the genes as the variables. The result was a gene-by-voxel expression matrix with 3958 genes and 61316 voxels.

## Human gene expression data

Human gene expression data was obtained from the Allen Human Brain Atlas [@Hawrylycz2012]. We used the microarray data from the brains of all 6 donors, each of which contains `log2` expression values for 58692 gene probes across numerous tissue samples. The data sets were fed through a pre-processing pipeline built following the recommendations from Arnatkeviciūtė et al. (2019) [@Arnatkeviciute2019]. Specifically, once imported, we passed the data from each donor through a set of filters. The first filter removed gene probes that were not associated with an existing Entrez gene ID. The second filtering step used the probe intensity filter provided by the AHBA. For each donor, we only retained the probes for which more than 50% of samples passed the intensity filter. After filtering, we aggregated the expression values for probes that corresponded to the same gene. To do so, we computed the average expression per sample for probes corresponding to a given gene. This was done separately for each donor, and the averages were computed in linear space rather than `log2` space. Once the average gene expression values were obtained, we transformed the data back to `log2` space. Finally, we combined the gene-by-sample expression matrices across the different donors. In doing so, we retained only those genes present in the data sets from all 6 donors. The result was a gene-by-sample expression matrix with 15125 genes and 3703 samples. 

## Mouse atlases

We used a modified version of the DSURQE atlas [@Dorr2008; @Richards2011; @Ullmann2013; @Steadman2014; @Qiu2018] at the Mouse Imaging Centre. The labels of the atlas are mapped to the finest regions in the AMBA ontology, resulting in a hierarchical neuranatomical tree. We used this tree to prune the hierarchy to the desired level of granularity. White matter and ventricular segmentations were removed entirely. The remaining grey matter regions were pruned so that the majority of leaf nodes contained enough voxels to be classified appropriately by the multi-layer perceptron. In doing so, we also attempted to maintain the same level of tree depth within a broad region, e.g. cerebellar regions were chosen at the same level of granularity. The leaf nodes of this tree were used as the labels in our custom atlas, resulting in a mouse atlas with 67 grey matter regions. We additionally generated an atlas with 11 broader regions for visualization and annotation purposes.

## Human atlases

For our human atlas we used the ontology from the AHBA. We pruned the neuroanatomical hierarchy to correspond roughly to the level of granularity in our mouse atlas, resulting in 88 human brain regions. We additionally generated a set of 16 broad regions for visualization and annotation. White matter and ventricular regions for ommitted entirely.

## Creating similarity matrices

We created the mouse and human gene expression blueprints from the human gene-by-sample expression matrix and the mouse gene-by-voxel expression matrix. We first intersected the gene sets in these matrices using a list of homologous genes obtained from the NCBI HomoloGene database. The resulting set contained `r length(genes)` homologous genes for both the mouse and human data. We then annotated each of the human samples with one of the 88 human regions in our atlas. The same was done for the mouse voxels with the 67 mouse atlas regions. Voxels and samples corresponding to white matter and ventricular regions were discarded in this process. These labelled expression matrices were subsequently normalized. For each matrix, we first standardized every gene across all voxels or samples. We then centered every voxel or sample across all genes. Finally, we generated the expression blueprints by averaging the expression of every homologous gene over the voxels or samples that corresponded to each atlas region. Using these blueprints, we computed the mouse-human similarity matrix by computing the Pearson correlation coefficient between all pairs of mouse and human regions. 

## Validating the multi-layer perceptron

Prior to training the multi-layer perceptron classifier, we applied a validation procedure to tune the hyperparameters of the network. We chose a model architecture in which each layer of the network was fully connected to the previous and subsequent layers. However we still had flexibility in setting a number of hyperparameters, namely the number of hidden layers in the network, the number of hidden units (i.e. neurons) per hidden layer, the dropout rate, and the amount of weight decay. Given that the majority of genes in the coronal AMBA data set are only sampled once over the entire mouse brain, we devised an ad hoc validation procedure to estimate the out-of-sample error of our model as we varied these hyperparameters. The process involved a combination of the coronal AMBA data set and the sagittal AMBA data set. Since the sagittal data set features more genes than the coronal data set, we first filtered the list of genes for those present in the coronal set. We then imported and pre-processed the sagittal data using the process described above for the coronal data set. Since the sagittal data set only covers one hemisphere of the mouse brain, we also repeated the importation and pre-processing process for the coronal data, but masking it using the sagittal brain mask so that only one hemisphere was retained. In applying this pipeline, we did not aggregate the expression of multiple ISH experiments for those genes featuring more than one experiment. Thus some of the genes in this coronal set had more than one sample. Once these gene-by-voxel expression matrices were built, we filtered each of them according to the list of mouse-human homologous genes and the human sample expression matrix. We then annotated the voxels in each of the mouse voxel expression matrices with one of the 67 regions in our atlas. In order to validate the MLP, we had to generate both a training set and a validation set. To do so, we applied the following procedure: For every gene in the homologous set, we first determined whether the gene had more than one sample in the coronal ISH data set. If this was the case, we randomly chose one of those samples for the training set and one of the remaining samples for the validation set. However if the gene only had a single sample in the coronal data set, we randomly chose either the coronal sample or the sagittal sample for the training set and the other for the validation set. Once the training and validation sets were generated, we trained the MLP on the training set and evaluated its performance on the validation set. Both the training and validation sets were normalized as described above prior to training. We repeated this entire procedure 10 times for every hyperparameter combination. We varied the number of hidden layers between 3 and 5. We varied the number of hidden units between 100 and 1000, increasing them in increments of 100. For the dropout rate, we examined values of 0, 0.25 and 0.50. For the amount of weight decay, we examined values of $10^{-6}$ and $10^{-5}$. Following this validation procedure, we found that the best performing model had 3 hidden layers, 200 neurons per layer, a dropout rate of 0, and a weight decay value of $10^{-6}$. This model had an average accuracy of 0.926 on the training sets and of 0.526 on the validation sets. 

## Training the multi-layer perceptron

Following validation, we trained the MLP classifier on the full coronal ISH data set from the AMBA. The voxel-wise expression matrices were labelled and normalized as described previously. The hyperparameters of the network were set to the optimal values obtained from the validation procedure. The network was trained using a learning rate of $10^{-5}$ over 200 epochs. \edit{Confirm what the loss function was for this and the validation procedure. Maybe also mention activation function, optimizer, etc.}. 

## Creating the gene expression latent space

The trained MLP was used to generate the new gene expression latent space. To do so, we removed the predictive output layer from the network architecture, thus allowing the hidden units of the third hidden layer to be the output of the network. We then applied this modified network to the mouse and human gene expression blueprints, resulting in matrices describing each brain region's weight over 200 hidden units. These matrices form the blueprints in the latent space. 

# References


